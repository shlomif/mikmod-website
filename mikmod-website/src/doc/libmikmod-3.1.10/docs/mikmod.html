<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang=
"en-US">
<head>
<meta name="generator" content=
"HTML Tidy for Linux (vers 25 March 2009), see www.w3.org" />
<title>MikMod sound library</title>
<meta http-equiv="Content-Type" content="text/html" />
<meta name="description" content="MikMod sound library" />
<meta name="generator" content="makeinfo 4.0" />
<link href="http://texinfo.org/" rel="generator-home" />
</head>
<body>
<hr />
Node:<a name="Top" id="Top">Top</a>, Next:<a rel="next" href=
"#Introduction">Introduction</a>, Previous:<a rel="previous" href=
"#(dir)">(dir)</a>, Up:<a rel="up" href="#(dir)">(dir)</a><br />
<h1>MikMod Sound Library</h1>
<p>
This&nbsp;manual&nbsp;documents&nbsp;the&nbsp;MikMod&nbsp;Sound&nbsp;Library,&nbsp;version&nbsp;3.1.10.</p>
<ul>
<li><a href="#Introduction">Introduction</a>: What is MikMod ?</li>
<li><a href="#Tutorial">Tutorial</a>: Your first steps with
MikMod.</li>
<li><a href="#Using_the_Library">Using the Library</a>: A
thematic presentation of the library.</li>
<li><a href="#Library_Reference">Library Reference</a>: Detailed
description of the functions and variables.</li>
<li><a href="#Index">Index</a>:</li>
</ul>
<hr />
Node:<a name="Introduction" id="Introduction">Introduction</a>,
Next:<a rel="next" href="#Tutorial">Tutorial</a>, Previous:<a rel=
"previous" href="#Top">Top</a>, Up:<a rel="up" href=
"#Top">Top</a><br />
<h1>Introduction</h1>
<p>The MikMod sound library is an excellent way for a programmer to
add music and sound effects to an application. It is a powerful and
flexible library, with a simple and easy-to-learn API.</p>
<p>Besides, the library is very portable and runs under a lot of
Unices, as well as under OS/2, MacOS and Windows. Third party
individuals also maintain ports on other systems, including MS-DOS,
and BeOS.</p>
<p>MikMod is able to play a wide range of module formats, as well
as digital sound files. It can take advantage of particular
features of your system, such as sound redirection over the
network. And due to its modular nature, the library can be extended
to support more sound or module formats, as well as new hardware or
other sound output capabilities, as they appear.</p>
<hr />
Node:<a name="Tutorial" id="Tutorial">Tutorial</a>, Next:<a rel=
"next" href="#Using_the_Library">Using the Library</a>,
Previous:<a rel="previous" href="#Introduction">Introduction</a>,
Up:<a rel="up" href="#Top">Top</a><br />
<h1>Tutorial</h1>
<p>This chapter will describe how to quickly incorporate MikMod's
power into your programs. It doesn't cover everything, but that's a
start and I hope it will help you understand the library
philosophy.</p>
<p>If you have a real tutorial to put here, you're welcome ! Please
send it to me…</p>
<ul>
<li><a href="#MikMod_Concepts">MikMod Concepts</a>: A few things
you'll need to know.</li>
<li><a href="#A_Skeleton_Program">A Skeleton Program</a>: The
shortest MikMod program.</li>
<li><a href="#Playing_Modules">Playing Modules</a>: How to create
a simple module player.</li>
<li><a href="#Playing_Sound_Effects">Playing Sound Effects</a>:
How to play simple sound effects.</li>
<li><a href="#More_Sound_Effects">More Sound Effects</a>: How
to play more complex sound effects.</li>
</ul>
<hr />
Node:<a name="MikMod_Concepts">MikMod Concepts</a>, Next:<a rel=
"next" href="#A_Skeleton_Program">A Skeleton Program</a>,
Previous:<a rel="previous" href="#Tutorial">Tutorial</a>,
Up:<a rel="up" href="#Tutorial">Tutorial</a><br />
<h2>MikMod Concepts</h2>
<p>MikMod's sound output is composed of several sound
<em>voices</em> which are mixed, either in software or in hardware,
depending of your hardware configuration. Simple sounds, like sound
effects, use only one voice, whereas sound modules, which are
complex arrangements of sound effects, use several voices.</p>
<p>MikMod's functions operate either globally, or at the voice
level. Differences in the handling of sound effects and modules are
kept minimal, at least for the programmer.</p>
<p>The sound playback is done by a <em>sound driver</em>. MikMod
provides several sound drivers: different hardware drivers, and
some software drivers to redirect sound in a file, or over the
network. You can even add your own driver, register it to make it
known by the library, and select it (this is exactly what the
module plugin of xmms does).</p>
<hr />
Node:<a name="A_Skeleton_Program">A Skeleton Program</a>,
Next:<a rel="next" href="#Playing_Modules">Playing Modules</a>,
Previous:<a rel="previous" href="#MikMod_Concepts">MikMod
Concepts</a>, Up:<a rel="up" href="#Tutorial">Tutorial</a><br />
<h2>A Skeleton Program</h2>
<p>To use MikMod in your program, there are a few steps
required:</p>
<ul>
<li>Include <code>mikmod.h</code> in your program.</li>
<li>Register the MikMod drivers you need.</li>
<li>Initialize the library with MikMod_Init() before using any
other MikMod function.</li>
<li>Give up resources with MikMod_Exit() at the end of your
program, or before when MikMod is not needed anymore.</li>
<li>Link your application with the MikMod sound library.</li>
</ul>
<p>Here's a program which meets all those conditions:</p>
<pre>
/* MikMod Sound Library example program: a skeleton */

#include &lt;mikmod.h&gt;

main()
{
        /* register all the drivers */
        MikMod_RegisterAllDrivers();

        /* initialize the library */
        MikMod_Init("");

        /* we could play some sound here... */

        /* give up */
        MikMod_Exit();
}
</pre>
<p>This program would be compiled with the following command line:
<code>cc -o example example.c `libmikmod-config --cflags`
`libmikmod-config --libs`</code></p>
<p>Although this programs produces no useful result, many things
happen when you run it. The call to
<code>MikMod_RegisterAllDrivers</code> registers all the drivers
embedded in the MikMod library. Then, <code>MikMod_Init</code>
chooses the more adequate driver and initializes it. The program is
now ready to produce sound. When sound is not needed any more,
<code>MikMod_Exit</code> is used to relinquish memory and let other
programs have access to the sound hardware.</p>
<hr />
Node:<a name="Playing_Modules">Playing Modules</a>, Next:<a rel=
"next" href="#Playing_Sound_Effects">Playing Sound Effects</a>,
Previous:<a rel="previous" href="#A_Skeleton_Program">A
Skeleton Program</a>, Up:<a rel="up" href=
"#Tutorial">Tutorial</a><br />
<h2>Playing Modules</h2>
<p>Our program is not really useful if it doesn't produce sound.
Let's suppose you've got this good old module, "Beyond music", in
the file <code>beyond music.mod</code>. How about playing it ?</p>
<p>To do this, we'll use the following code:</p>
<pre>
/* MikMod Sound Library example program: a simple module player */

#include &lt;unistd.h&gt;
#include &lt;mikmod.h&gt;

main()
{
    MODULE *module;

    /* register all the drivers */
    MikMod_RegisterAllDrivers();

    /* register all the module loaders */
    MikMod_RegisterAllLoaders();

    /* initialize the library */
    md_mode |= DMODE_SOFT_MUSIC;
    if (MikMod_Init("")) {
        fprintf(stderr, "Could not initialize sound, reason: %s\n",
                MikMod_strerror(MikMod_errno));
        return;
    }

    /* load module */
    module = Player_Load("beyond music.mod", 64, 0);
    if (module) {
        /* start module */
        Player_Start(module);

        while (Player_Active()) {
            /* we're playing */
            usleep(10000);
            MikMod_Update();
        }

        Player_Stop();
        Player_Free(module);
    } else
        fprintf(stderr, "Could not load module, reason: %s\n",
                MikMod_strerror(MikMod_errno));

    /* give up */
    MikMod_Exit();
}
</pre>
<p>What's new here ? First, we've not only registered MikMod's
device driver, but also the module loaders. MikMod comes with a
large choice of module loaders, each one for a different module
type. Since <em>every</em> loader is called to determine the type
of the module when we try to load them, you may want to register
only a few of them to save time. In our case, we don't matter, so
we happily register every module loader.</p>
<p>Then, there's an extra line before calling
<code>MikMod_Init</code>. We change the value of MikMod's variable
<code>md_mode</code> to tell the library that we want the module to
be processed by the software. If you're the happy owner of a
GUS-type card, you could use the specific hardware driver for this
card, but in this case you should not set the
<code>DMODE_SOFT_MUSIC</code> flag.</p>
<p>We'll ensure that <code>MikMod_Init</code> was successful. Note
that, in case of error, MikMod provides the variable
<code>MikMod_errno</code>, an equivalent of the C library
<code>errno</code> for MikMod errors, and the function
<code>MikMod_strerror</code>, an equivalent to
<code>strerror</code>.</p>
<p>Now onto serious business ! The module is loaded with the
<code>Player_Load</code> function, which takes the name of the
module file, and the number of voices afforded to the module. In
this case, the module has only 4 channels, so 4 voices, but complex
Impulse Tracker modules can have a lot of voices (as they can have
as many as 256 virtual channels with so-called "new note actions").
Since empty voices don't cost time to be processed, it is safe to
use a big value, such as 64 or 128. The third parameter is the
"curiosity" of the loader: if nonzero, the loader will search for
hidden parts in the module. However, only a few module formats can
embed hidden or non played parts, so we'll use 0 here.</p>
<p>Now that the module is ready to play, let's play it. We inform
the player that the current module is <code>module</code> with
<code>Player_Start</code>. Playback starts, but we have to update
it on a regular basis. So there's a loop on the result of the
<code>Player_Active</code> function, which will tell us if the
module has finished. To update the sound, we simply call
<code>MikMod_Update</code>.</p>
<p>After the module has finished, we tell the player its job is
done with <code>Player_Stop</code>, and we free the module with
<code>Player_Free</code>.</p>
<hr />
Node:<a name="Playing_Sound_Effects">Playing Sound Effects</a>,
Next:<a rel="next" href="#More_Sound_Effects">More Sound
Effects</a>, Previous:<a rel="previous" href=
"#Playing_Modules">Playing Modules</a>, Up:<a rel="up" href=
"#Tutorial">Tutorial</a><br />
<h2>Playing Sound Effects</h2>
<p>MikMod is not limited to playing modules, it can also play sound
effects, that is, module samples. It's a bit more complex than
playing a module, because the module player does a lot of things
for us, but here we'll get more control over what is actually
played by the program. Let's look at an example:</p>
<pre>
/* MikMod Sound Library example program: sound effects */

#include &lt;unistd.h&gt;
#include &lt;mikmod.h&gt;

main()
{
    int i;
    /* sound effects */
    SAMPLE *sfx1, *sfx2;
    /* voices */
    int v1, v2;

    /* register all the drivers */
    MikMod_RegisterAllDrivers();

    /* initialize the library */
    md_mode |= DMODE_SOFT_SNDFX;
    if (MikMod_Init("")) {
        fprintf(stderr, "Could not initialize sound, reason: %s\n",
                MikMod_strerror(MikMod_errno));
        return;
    }

    /* load samples */
    sfx1 = Sample_Load("first.wav");
    if (!sfx1) {
        MikMod_Exit();
        fprintf(stderr, "Could not load the first sound, reason: %s\n",
                MikMod_strerror(MikMod_errno));
        return;
    }
    sfx2 = Sample_Load("second.wav");
    if (!sfx2) {
        Sample_Free(sfx1);
        MikMod_Exit();
        fprintf(stderr, "Could not load the second sound, reason: %s\n",
                MikMod_strerror(MikMod_errno));
        return;
    }

    /* reserve 2 voices for sound effects */
    MikMod_SetNumVoices(-1, 2);

    /* get ready to play */
    MikMod_EnableOutput();

    /* play first sample */
    v1 = Sample_Play(sfx1, 0, 0);
    for(i = 0; i &lt; 5; i++) {
        MikMod_Update();
        usleep(100000);
    }

    /* half a second later, play second sample */
    v2 = Sample_Play(sfx2, 0, 0);
    do {
        MikMod_Update();
        usleep(100000);
    } while (!Voice_Stopped(v2));

    MikMod_DisableOutput();

    Sample_Free(sfx2);
    Sample_Free(sfx1);

    MikMod_Exit();
}
</pre>
<p>As in the previous example, we begin by registering the sound
drivers and initializing the library. We also ask for software
mixing by modifying the variable <code>md_mode</code>.</p>
<p>It's time to load our files, with the <code>Sample_Load</code>
function. Don't forget to test the return value -- it looks ugly
here on such a small example, but it's a good
practice….</p>
<p>Since we want to play two samples, we have to use at least two
voices for this, so we reserve them with a
<code>MikMod_SetNumVoices</code> call. The first parameter sets the
number of module voices, and the second parameter the number of
sound effect voices. We don't want to set the number of module
voices here (it's part of the module player's duty), so we use the
value <code>-1</code> to keep the current value, and we reserve two
sound effect voices.</p>
<p>Now we're ready to play, so we call
<code>MikMod_EnableOutput</code> to make the driver ready. Sound
effects are played by the <code>Sample_Play</code> function. You
just have to specify which sample you want to play, the offset from
which you want to start, and the playback flags. More on this
later. The function returns the number of the voice associated to
the sample.</p>
<p>We play the first sample for half a second, then we start to
play the second sample. Since we've reserved two channels, both
samples play simultaneously. We use the <code>Voice_Stopped</code>
function to stop the playback: it returns the current status of the
voice argument, which is zero when the sample plays and nonzero
when it has finished. So the <code>do</code> loop will stop exactly
when the second sample is finished, regardless of the length of the
first sample.</p>
<p>To finish, we get rid of the samples with
<code>Sample_Free</code>.</p>
<hr />
Node:<a name="More_Sound_Effects">More Sound Effects</a>,
Previous:<a rel="previous" href=
"#Playing_Sound_Effects">Playing Sound Effects</a>, Up:<a rel=
"up" href="#Tutorial">Tutorial</a><br />
<h2>More Sound Effects</h2>
<p>Sound effects have some attributes that can be affected to
control the playback. These are speed, panning, and volume. Given a
voice number, you can affect these attributes with the
<code>Voice_SetFrequency</code>, <code>Voice_SetPanning</code> and
<code>Voice_SetVolume</code> functions.</p>
<p>In the previous example, we'll replace the actual sound code,
located between the calls to <code>MikMod_EnableOutput</code> and
<code>MikMod_DisableOutput</code>, with the following code:</p>
<pre>
    Sample_Play(sfx1, 0, 0);
    for(i = 0; i &lt; 5; i++) {
        MikMod_Update();
        usleep(100000);
    }
    v2 = Sample_Play(sfx2, 0, SFX_CRITICAL);
    i = 0;
    do {
        MikMod_Update();
        usleep(100000);
        v1 = Sample_Play(sfx1, 0, 0);
        Voice_SetVolume(v1, 160);
        Voice_SetFrequency(v1, (sfx1-&gt;speed * (100 + i)) / 100);
        Voice_SetPanning(v2, (i++ &amp; 1) ? PAN_LEFT : PAN_RIGHT);
    } while (!Voice_Stopped(v2));
</pre>
<p>The first thing you'll notice, is the <code>SFX_CRITICAL</code>
flag used to play the second sample. Since the <code>do</code> loop
will add another sample every 100 milliseconds, and we reserved
only two voices, the oldest voice will be cut each time this is
necessary. Doing this would cut the second sample in the second
iteration of the loop. However, since we flagged this sound as
"critical", it won't be cut until it is finished or we stop it with
a <code>Voice_Stop</code> call. So the second sample will play
fine, whereas the first sample will be stopped every loop
iteration.</p>
<p>Then, we choose to play the first sample a bit lower, with
<code>Voice_SetVolume</code>. Volume voices range from 0 (silence)
to 256. In this case we play the sample at 160. To make the sound
look weird, we also change its frequency with
<code>Voice_SetFrequency</code>. The computation in the example
code makes the frequency more and more high (starting from the
sample frequency and then increasing from 1% each iteration).</p>
<p>And to demonstrate the <code>Voice_SetPanning</code> function,
we change the panning of the second sample at each iteration from
the left to the right. The argument can be one of the standard
panning <code>PAN_LEFT</code>, <code>PAN_RIGHT</code>,
<code>PAN_CENTER</code> and <code>PAN_SURROUND</code><a rel=
"footnote" href="#fn-1"><sup>1</sup></a>, or a numeric value
between 0 (<code>PAN_LEFT</code>) and 255
(<code>PAN_RIGHT</code>).</p>
<hr />
Node:<a name="Using_the_Library">Using the Library</a>,
Next:<a rel="next" href="#Library_Reference">Library
Reference</a>, Previous:<a rel="previous" href=
"#Tutorial">Tutorial</a>, Up:<a rel="up" href="#Top">Top</a><br />
<h1>Using the Library</h1>
<p>This chapter describes the various parts of the library and
their uses.</p>
<ul>
<li><a href="#Library_Version">Library Version</a>:</li>
<li><a href="#Type_Definitions">Type Definitions</a>:</li>
<li><a href="#Error_Handling">Error Handling</a>:</li>
<li><a href="#Library_Initialization">Library
Initialization</a>:</li>
<li><a href="#Samples_and_Voice_Control">Samples and Voice
Control</a>:</li>
<li><a href="#Modules_and_Player_Control">Modules and Player
Control</a>:</li>
<li><a href="#Loading_Data_from_Memory">Loading Data from
Memory</a>:</li>
</ul>
<hr />
Node:<a name="Library_Version">Library Version</a>, Next:<a rel=
"next" href="#Type_Definitions">Type Definitions</a>,
Previous:<a rel="previous" href="#Using_the_Library">Using the
Library</a>, Up:<a rel="up" href="#Using_the_Library">Using the
Library</a><br />
<h2>Library Version</h2>
<p>If your program is dynamically linked with the MikMod library,
you should check which version of the library you're working with.
To do this, the library defines a few constants and a function to
help you determine if the current library is adequate for your
needs or if it has to be upgraded.</p>
<p>When your program includes <code>mikmod.h</code>, the following
constants are defined:</p>
<ul>
<li><code>LIBMIKMOD_VERSION_MAJOR</code> is equal to the major
version number of the library.</li>
<li><code>LIBMIKMOD_VERSION_MINOR</code> is equal to the minor
version number of the library.</li>
<li><code>LIBMIKMOD_REVISION</code> is equal to the revision number
of the library.</li>
<li><code>LIBMIKMOD_VERSION</code> is the sum of
<code>LIBMIKMOD_VERSION_MAJOR</code> shifted 16 times,
<code>LIBMIKMOD_VERSION_MINOR</code> shifted 8 times, and
<code>LIBMIKMOD_REVISION</code>.</li>
</ul>
<p>So your program can tell with which version of the library it
has been compiled this way:</p>
<pre>
printf("Compiled with MikMod Sound Library version %ld.%ld.%ld\n",
       LIBMIKMOD_VERSION_MAJOR,
       LIBMIKMOD_VERSION_MINOR,
       LIBMIKMOD_REVISION);
</pre>
<p>The library defines the function <code>MikMod_GetVersion</code>
which returns the value of LIBMIKMOD_VERSION for the library. If
this value is greater than or equal to the value of
LIBMIKMOD_VERSION for your program, your program will work;
otherwise, you'll have to inform the user that he has to upgrade
the library:</p>
<pre>
{
    long engineversion = MikMod_GetVersion();

    if (engineversion &lt; LIBMIKMOD_VERSION) {
        printf("MikMod library version (%ld.%ld.%ld) is too old.\n",
               (engineversion &gt;&gt; 16) &amp; 255,
               (engineversion &gt;&gt; 8) &amp; 255,
               (engineversion) &amp; 255);
        printf("This programs requires at least version %ld.%ld.%ld\n",
               LIBMIKMOD_VERSION_MAJOR,
               LIBMIKMOD_VERSION_MINOR,
               LIBMIKMOD_REVISION);
        puts("Please upgrade your MikMod library.");
        exit(1);
    }
}
</pre>
<hr />
Node:<a name="Type_Definitions">Type Definitions</a>,
Next:<a rel="next" href="#Error_Handling">Error Handling</a>,
Previous:<a rel="previous" href="#Library_Version">Library
Version</a>, Up:<a rel="up" href="#Using_the_Library">Using the
Library</a><br />
<h2>Type Definitions</h2>
<p>MikMod defines several data types to deal with modules and
sample data. These types have the same memory size on every
platform MikMod has been ported to.</p>
<p>These types are:</p>
<ul>
<li><code>CHAR</code> is a printable character. For now it is the
same as the <code>char</code> type, but in the future it may be
wide char (Unicode) on some platforms.</li>
<li><code>SBYTE</code> is a signed 8 bit number (can range from
-128 to 127).</li>
<li><code>UBYTE</code> is an unsigned 8 bit number (can range from
0 to 255).</li>
<li><code>SWORD</code> is a signed 16 bit number (can range from
-32768 to 32767).</li>
<li><code>UWORD</code> is an unsigned 16 bit number (can range from
0 to 65535).</li>
<li><code>SLONG</code> is a signed 32 bit number (can range from
-2.147.483.648 to 2.147.483.647).</li>
<li><code>ULONG</code> is an unsigned 32 bit number (can range from
0 to 4.294.967.296).</li>
<li><code>BOOL</code> is a boolean value. A value of 0 means false,
any other value means true.</li>
</ul>
<hr />
Node:<a name="Error_Handling">Error Handling</a>, Next:<a rel=
"next" href="#Library_Initialization">Library Initialization</a>,
Previous:<a rel="previous" href="#Type_Definitions">Type
Definitions</a>, Up:<a rel="up" href="#Using_the_Library">Using
the Library</a><br />
<h2>Error Handling</h2>
<p>Although MikMod does its best to do its work, there are times
where it can't. For example, if you're trying to play a corrupted
file, well, it can't.</p>
<p>A lot of MikMod functions return pointers or <code>BOOL</code>
values. If the pointer is <code>NULL</code> or the
<code>BOOL</code> is 0 (false), an error has occurred.</p>
<p>MikMod errors are returned in the variable
<code>MikMod_errno</code>. Each possible error has a symbolic error
code, beginning with <code>MMERR_</code>. For example, if MikMod
can't open a file, <code>MikMod_errno</code> will receive the value
<code>MMERR_OPENING_FILE</code>.</p>
<p>You can get an appropriate error message to display from the
function <code>MikMod_strerror</code>.</p>
<p>There is a second error variable named
<code>MikMod_critical</code>. As its name suggests, it is only set
if the error lets the library in an unstable state. This variable
can only be set by the functions <code>MikMod_Init</code>,
<code>MikMod_SetNumVoices</code> and
<code>MikMod_EnableOutput</code>. If one of these functions return
an error and <code>MikMod_critical</code> is set, the library is
left in the uninitialized state (i.e. it was not initialized, or
<code>MikMod_Exit</code> was called).</p>
<p>If you prefer, you can use a callback function to get notified
of errors. This function must be prototyped as <code>void
MyFunction(void)</code>. Then, call
<code>MikMod_RegisterHandler</code> with your function as argument
to have it notified when an error occurs. There can only be one
callback function registered, but
<code>MikMod_RegisterHandler</code> will return you the previous
handler, so you can chain handlers if you want to.</p>
<hr />
Node:<a name="Library_Initialization">Library Initialization</a>,
Next:<a rel="next" href="#Samples_and_Voice_Control">Samples
and Voice Control</a>, Previous:<a rel="previous" href=
"#Error_Handling">Error Handling</a>, Up:<a rel="up" href=
"#Using_the_Library">Using the Library</a><br />
<h2>Library Initialization and Core Functions</h2>
<p>To initialize the library, you must register some sound drivers
first. You can either register all the drivers embedded in the
library for your platform with
<code>MikMod_RegisterAllDrivers</code>, or register only some of
them with <code>MikMod_RegisterDriver</code>. If you choose to
register the drivers manually, you must be careful in their order,
since <code>MikMod_Init</code> will try them in the order you
registered them. The <code>MikMod_RegisterAllDrivers</code>
function registers the network drivers first (for playing sound
over the network), then the hardware drivers, then the disk
writers, and in last resort, the nosound driver. Registering the
nosound driver first would not be a very good
idea….</p>
<p>You can get some printable information regarding the registered
drivers with <code>MikMod_InfoDriver</code>; don't forget to call
<code>free</code> on the returned string when you don't need it
anymore.</p>
<p>After you've registered your drivers, you can initialize the
sound playback with <code>MikMod_Init</code>, passing specific
information to the driver if necessary. If you set the variable
<code>md_device</code> to zero, which is its default value, the
driver will be autodetected, that is, the first driver in the list
that is available on the system will be used; otherwise only the
driver whose order in the list of the registered drivers is equal
to <code>md_device</code> will be tried. If your playback settings,
in the variables <code>md_mixfreq</code> and <code>md_mode</code>,
are not supported by the device, <code>MikMod_Init</code> will
fail.</p>
<p>You can then choose the number of voices you need with
<code>MikMod_SetNumVoices</code>, and activate the playback with
<code>MikMod_EnableOutput</code>.</p>
<p>Don't forget to call <code>MikMod_Update</code> as often as
possible to process the sound mixing. If necessary, fork a
dedicated process to do this, or if the library is thread-safe on
your system, use a dedicated thread.</p>
<p>If you want to change playback settings, most of them can't be
changed on the fly. You'll need to stop the playback and
reinitialize the driver. Use <code>MikMod_Active</code> to check if
there is still sound playing; in this case, call
<code>MikMod_DisableOutput</code> to end playback. Then, change
your settings and call <code>MikMod_Reset</code>. You're now ready
to select your number of voices and restart playback.</p>
<p>When your program ends, don't forget to stop playback and call
<code>MikMod_Exit</code> to leave the sound hardware in a coherent
state.</p>
<p>On systems that have pthreads, libmikmod is thread-safe<a rel=
"footnote" href="#fn-2"><sup>2</sup></a>. You can check this in
your programs with the <code>MikMod_InitThreads</code> function. If
this function returns 1, the library is thread-safe.</p>
<p>The main benefit of thread-safety is that
<code>MikMod_Update</code> can be called from a separate thread,
which often makes application design easier. However, several
libmikmod global variables are accessible from all your threads, so
when more than one thread need to access libmikmod variables,
you'll have to protect these access with the
<code>MikMod_Lock</code> and <code>MikMod_Unlock</code> functions.
If libmikmod is not thread-safe, these functions are no-ops.</p>
<hr />
Node:<a name="Samples_and_Voice_Control">Samples and Voice
Control</a>, Next:<a rel="next" href=
"#Modules_and_Player_Control">Modules and Player Control</a>,
Previous:<a rel="previous" href="#Library_Initialization">Library
Initialization</a>, Up:<a rel="up" href=
"#Using_the_Library">Using the Library</a><br />
<h2>Samples and Voice Control</h2>
<p>Currently, MikMod only supports uncompressed mono WAV files as
samples. You can load a sample by calling <code>Sample_Load</code>
with a filename, or by calling <code>Sample_LoadFP</code> with an
open <code>FILE*</code> pointer. These functions return a pointer
to a <code>SAMPLE</code> structure, or <code>NULL</code> in case of
error.</p>
<p>The <code>SAMPLE</code> structure has a few interesting
fields:</p>
<ul>
<li><code>speed</code> contains the default frequency of the
sample.</li>
<li><code>volume</code> contains the default volume of the sample,
ranging from 0 (silence) to 64.</li>
<li><code>panning</code> contains the default panning position of
the sample.</li>
</ul>
<p>Altering one of those fields will affect all voices currently
playing the sample. You can achieve the same result on a single
voice with the functions <code>Voice_SetFrequency</code>,
<code>Voice_SetVolume</code> and <code>Voice_SetPanning</code>.
Since the same sample can be played with different frequency,
volume and panning parameters on each voice, you can get voice
specific information with <code>Voice_GetFrequency</code>,
<code>Voice_GetVolume</code> and <code>Voice_GetPanning</code>.</p>
<p>You can also make your sample loop by setting the fields
<code>loopstart</code> and <code>loopend</code> and or'ing
<code>flags</code> with <code>SF_LOOP</code>. To compute your loop
values, the field <code>length</code> will be useful. However, you
must know that all the sample length are expressed in samples, i.e.
8 bits for an 8 bit sample, and 16 bit for a 16 bit
sample… Test <code>flags</code> for the value
<code>SF_16BITS</code> to know this.</p>
<p>Speaking of flags, if you're curious and want to know the
original format of the sample on disk (since libmikmod does some
work on the sample data internally), refer to the
<code>inflags</code> field.</p>
<p>If the common forward loop isn't enough, you can play with some
other flags: <code>SF_BIDI</code> will make your sample loop "ping
pong" (back and forth), and <code>SF_REVERSE</code> will make it
play backwards.</p>
<p>To play your sample, use the <code>Sample_Play</code> function.
This function will return a voice number which enable you to use
the <code>Voice_xx</code> functions.</p>
<p>The sample will play until another sample takes over its voice
(when you play more samples than you reserved sound effect voices),
unless it has been flagged as <code>SFX_CRITICAL</code>. You can
force it to stop with <code>Voice_Stop</code>, or you can force
another sample to take over this voice with
<code>Voice_Play</code>; however <code>Voice_Play</code> doesn't
let you flag the new sample as critical.</p>
<p>Non looping samples will free their voice channel as soon as
they are finished; you can know the current playback position of
your sample with <code>Voice_GetPosition</code>. If it is zero,
either the sample has finished playing or it is just beginning; use
<code>Voice_Stopped</code> to know.</p>
<p>When you don't need a sample anymore, don't forget to free its
memory with <code>Sample_Free</code>.</p>
<hr />
Node:<a name="Modules_and_Player_Control">Modules and Player
Control</a>, Next:<a rel="next" href=
"#Loading_Data_from_Memory">Loading Data from Memory</a>,
Previous:<a rel="previous" href=
"#Samples_and_Voice_Control">Samples and Voice Control</a>,
Up:<a rel="up" href="#Using_the_Library">Using the
Library</a><br />
<h2>Modules and Player Control</h2>
<p>As for the sound drivers, you have to register the module
loaders you want to use for MikMod to be able to load modules. You
can either register all the module loaders with
<code>MikMod_RegisterAllLoaders</code>, or only a few of them with
<code>MikMod_RegisterLoader</code>. Be careful if you choose this
solution, as the 15 instrument MOD loader has to be registered
last, since loaders are called in the order they were register to
identify modules, and the detection of this format is not fully
reliable, so other modules might be mistaken as 15 instrument MOD
files.</p>
<p>You can get some printable information regarding the registered
loaders with <code>MikMod_InfoLoader</code>; don't forget to call
<code>free</code> on the returned string when you don't need it
anymore.</p>
<p>Note that, contrary to the sound drivers, you can register
module loaders at any time, it doesn't matter.</p>
<p>For playlists, you might be interested in knowing the module
title first, and <code>Player_LoadTitle</code> will give you this
information. Don't forget to <code>free</code> the returned text
when you don't need it anymore.</p>
<p>You can load a module either with <code>Player_Load</code> and
the name of the module, or with <code>Player_LoadFP</code> and an
open <code>FILE*</code> pointer. These functions also expect a
maximal number of voices, and a curiosity flag. Unless you have
excellent reasons not to do so, choose a big limit, such as 64 or
even 128 for complex Impulse Tracker modules. Both functions return
a pointer to an <code>MODULE</code> structure, or <code>NULL</code>
if an error occurs.</p>
<p>You'll find some useful information in this structure:</p>
<ul>
<li><code>numchn</code> contains the number of module "real"
channels.</li>
<li><code>numvoices</code> contains the number of voices reserved
by the player for the real channels and the virtual channels
(NNA).</li>
<li><code>numpas</code> and <code>numpat</code> contain the number
of song positions and song patterns.</li>
<li><code>numins</code> and <code>numsmp</code> contain the number
of instruments and samples.</li>
<li><code>songname</code> contains the song title.</li>
<li><code>modtype</code> contains the name of the tracker used to
create the song.</li>
<li><code>comment</code> contains the song comment, if it has
one.</li>
<li><code>sngtime</code> contains the time elapsed in the module,
in 2^-10 seconds (not exactly a millisecond).</li>
<li><code>sngspd</code> and <code>bpm</code> contain the song speed
and tempo.</li>
<li><code>realchn</code> contains the actual number of active
channels.</li>
<li><code>totalchn</code> contains the actual number of active
virtual channels, i.e. the sum of <code>realchn</code> and the
number of NNA virtual channels.</li>
</ul>
<p>Now that the module is loaded, you need to tell the module
player that you want to play this particular module with
<code>Player_Start</code> (the player can only play one module, but
you can have several modules in memory). The playback begins.
Should you forget which module is playing,
<code>Player_GetModule</code> will return it to you.</p>
<p>You can change the current song position with the functions
<code>Player_NextPosition</code>, <code>Player_PrevPosition</code>
and <code>Player_SetPosition</code>, the speed with
<code>Player_SetSpeed</code> and <code>Player_SetTempo</code>, and
the volume (ranging from 0 to 128) with
<code>Player_SetVolume</code>.</p>
<p>Playback can be paused or resumed with
<code>Player_TogglePause</code>. Be sure to check with
<code>Player_Paused</code> that it isn't already in the state you
want !</p>
<p>Fine player control is achieved by the functions
<code>Player_Mute</code>, <code>Player_UnMute</code> and
<code>Player_ToggleMute</code> which can silence or resume a set of
module channels. The function <code>Player_Muted</code> will return
the state of a given channel. And if you want even more control,
you can get the voice corresponding to a module channel with
<code>Player_GetChannelVoice</code> and act directly on the
voice.</p>
<p>Modules play only once, but can loop indefinitely if they are
designed to do so. You can change this behavior with the
<code>wrap</code> and <code>loop</code> of the <code>MODULE</code>
structure; the first one, if set, will make the module restart when
it's finished, and the second one, if set, will prevent the module
from jumping backwards.</p>
<p>You can test if the module is still playing with
<code>Player_Active</code>, and you can stop it at any time with
<code>Player_Stop</code>. When the module isn't needed anymore, get
rid of it with <code>Player_Free</code>.</p>
<hr />
Node:<a name="Loading_Data_from_Memory">Loading Data from
Memory</a>, Previous:<a rel="previous" href=
"#Modules_and_Player_Control">Modules and Player Control</a>,
Up:<a rel="up" href="#Using_the_Library">Using the
Library</a><br />
<h2>Loading Data from Memory</h2>
<p>If you need to load modules or sound effects from other places
than plain files, you can use the <code>MREADER</code> and
<code>MWRITER</code> objects to achieve this.</p>
<p>The <code>MREADER</code> and <code>MWRITER</code> structures
contain a list of function pointers, which emulate the behaviour of
a regular <code>FILE *</code> object. In fact, all functions which
take filenames or <code>FILE *</code> as arguments are only
wrappers to a real function which takes an <code>MREADER</code> or
an <code>MWRITER</code> argument.</p>
<p>So, if you need to load a module from memory, or for a
multi-file archive, for example, all you need is to build an
adequate <code>MREADER</code> object, and use
<code>Player_LoadGeneric</code> instead of <code>Player_Load</code>
or <code>Player_LoadFP</code>. For samples, use
<code>Sample_LoadGeneric</code> instead of <code>Sample_Load</code>
or <code>Sample_LoadFP</code>.</p>
<hr />
Node:<a name="Library_Reference">Library Reference</a>,
Next:<a rel="next" href="#Index">Index</a>, Previous:<a rel=
"previous" href="#Using_the_Library">Using the Library</a>,
Up:<a rel="up" href="#Top">Top</a><br />
<h1>Library Reference</h1>
<p>This chapter describes in more detail all the functions and
variables provided by the library. See <a href=
"#Type_Definitions">Type Definitions</a>, for the basic type
reference.</p>
<ul>
<li><a href="#Variable_Reference">Variable Reference</a>:</li>
<li><a href="#Structure_Reference">Structure Reference</a>:</li>
<li><a href="#Error_Reference">Error Reference</a>:</li>
<li><a href="#Function_Reference">Function Reference</a>:</li>
<li><a href="#Loader_Reference">Loader Reference</a>:</li>
<li><a href="#Driver_Reference">Driver Reference</a>:</li>
</ul>
<hr />
Node:<a name="Variable_Reference">Variable Reference</a>,
Next:<a rel="next" href="#Structure_Reference">Structure
Reference</a>, Previous:<a rel="previous" href=
"#Library_Reference">Library Reference</a>, Up:<a rel="up" href=
"#Library_Reference">Library Reference</a><br />
<h2>Variable Reference</h2>
<h3>Error Variables</h3>
<p>The following variables are set by the library to return error
information.</p>
<dl>
<dt><code>int MikMod_errno</code></dt>
<dd>When an error occurs, this variable contains the error code.
See <a href="#Error_Reference">Error Reference</a>, for more
information.<br /></dd>
<dt><code>BOOL MikMod_critical</code></dt>
<dd>When an error occurs, this variable informs of the severity of
the error. Its value has sense only if the value of
<code>MikMod_errno</code> is different from zero. If the value of
<code>MikMod_critical</code> is zero, the error wasn't fatal and
the library is in a stable state. However, if it is nonzero, then
the library can't be used and has reseted itself to the
uninitialized state. This often means that the mixing parameters
you choose were not supported by the driver, or that it doesn't has
enough voices for your needs if you called
<code>MikMod_SetNumVoices</code>.</dd>
</dl>
<h3>Sound Settings</h3>
<p>The following variables control the sound output parameters and
their changes take effect immediately.</p>
<dl>
<dt><code>UBYTE md_musicvolume</code></dt>
<dd>Volume of the module. Allowed values range from 0 to 128. The
default value is 128.<br /></dd>
<dt><code>UBYTE md_pansep</code></dt>
<dd>Stereo channels separation. Allowed values range from 0 (no
separation, thus mono sound) to 128 (full channel separation). The
default value is 128.<br /></dd>
<dt><code>UBYTE md_reverb</code></dt>
<dd>Amount of sound reverberation. Allowed values range from 0 (no
reverberation) to 15 (a rough estimate for
chaos…). The default value is 0.<br /></dd>
<dt><code>UBYTE md_sndfxvolume</code></dt>
<dd>Volume of the sound effects. Allowed values range from 0 to
128. The default value is 128.<br /></dd>
<dt><code>UBYTE md_volume</code></dt>
<dd>Overall sound volume. Allowed values range from 0 to 128. The
default value is 128.</dd>
</dl>
<h3>Driver Settings</h3>
<p>The following variables control more in-depth sound output
parameters. Except for some <code>md_mode</code> flags, their
changes do not have any effect until you call
<code>MikMod_Init</code> or <code>MikMod_Reset</code>.</p>
<dl>
<dt><code>UWORD md_device</code></dt>
<dd>This variable contains the order, in the list of the registered
drivers, of the sound driver which will be used for sound playback.
This order is one-based; if this variable is set to zero, the
driver is autodetected, which means the list is tested until a
driver is present on the system. The default value is 0, thus
driver is autodetected.<br /></dd>
<dt><code>MDRIVER* md_driver</code></dt>
<dd>This variable points to the driver which is being used for
sound playback, and is undefined when the library is uninitialized
(before <code>MikMod_Init</code> and after
<code>MikMod_Exit</code>). This variable is for information only,
you should never attempt to change its value. Use
<code>md_driver</code> and <code>MikMod_Init</code> (or
<code>MikMod_Reset</code>) instead.<br /></dd>
<dt><code>UWORD md_mixfreq</code></dt>
<dd>Sound playback frequency, in hertz. High values yield high
sound quality, but need more computing power than lower values. The
default value is 44100 Hz, which is compact disc quality. Other
common values are 22100 Hz (radio quality), 11025 Hz (phone
quality), and 8000 Hz (mu-law quality).<br /></dd>
<dt><code>UWORD md_mode</code></dt>
<dd>This variable is a combination of several flags, to select
which output mode to select. The following flags have a direct
action to the sound output (i.e. changes take effect immediately):
<dl>
<dt><code>DMODE_INTERP</code></dt>
<dd>This flag, if set, enables the interpolated mixers.
Interpolated mixing gives better sound but takes a bit more time
than standard mixing. If the library is built with the high quality
mixer, interpolated mixing is always enabled, regardless of this
flag.<br /></dd>
<dt><code>DMODE_REVERSE</code></dt>
<dd>This flag, if set, exchanges the left and right stereo
channels.<br /></dd>
<dt><code>DMODE_SURROUND</code></dt>
<dd>This flag, if set, enables the surround mixers. Since surround
mixing works only for stereo sound, this flag has no effect if the
sound playback is in mono.</dd>
</dl>
<br />
The following flags aren't taken in account until the sound driver
is changed or reset:
<dl>
<dt><code>DMODE_16BIT</code></dt>
<dd>This flag, if set, selects 16 bit sound mode. This mode yields
better sound quality, but needs twice more mixing time.<br /></dd>
<dt><code>DMODE_HQMIXER</code></dt>
<dd>This flag, if set, selects the high-quality software mixer.
This mode yields better sound quality, but needs more mixing time.
Of course, this flag has no effect if no <code>DMODE_SOFT_xx</code>
flag is set.<br /></dd>
<dt><code>DMODE_SOFT_MUSIC</code></dt>
<dd>This flag, if set, selects software mixing of the
module.<br /></dd>
<dt><code>DMODE_SOFT_SNDFX</code></dt>
<dd>This flag, if set, selects software mixing of the sound
effects.<br /></dd>
<dt><code>DMODE_STEREO</code></dt>
<dd>This flag, if set, selects stereo sound.</dd>
</dl>
<br />
The default value of this variable is <code>DMODE_STEREO |
DMODE_SURROUND | DMODE_16BITS | DMODE_SOFT_MUSIC |
DMODE_SOFT_SNDFX</code>.</dd>
</dl>
<hr />
Node:<a name="Structure_Reference">Structure Reference</a>,
Next:<a rel="next" href="#Error_Reference">Error Reference</a>,
Previous:<a rel="previous" href="#Variable_Reference">Variable
Reference</a>, Up:<a rel="up" href="#Library_Reference">Library
Reference</a><br />
<h2>Structure Reference</h2>
<p>Only the useful fields are described here; if a structure field
is not described, you must assume that it's an internal field which
must not be modified.</p>
<h3>Drivers</h3>
<p>The <code>MDRIVER</code> structure is not meant to be used by
anything else than the core of the library, but its first four
fields contain useful information for your programs:</p>
<dl>
<dt><code>CHAR* Name</code></dt>
<dd>Name of the driver, usually never more than 20
characters.<br /></dd>
<dt><code>CHAR* Description</code></dt>
<dd>Description of the driver, usually never more than 50
characters.<br /></dd>
<dt><code>UBYTE HardVoiceLimit</code></dt>
<dd>Maximum number of hardware voices for this driver, 0 if the
driver has no hardware mixing support.<br /></dd>
<dt><code>UBYTE SoftVoiceLimit</code></dt>
<dd>Maximum number of software voices for this driver, 0 if the
driver has no software mixing support.<br /></dd>
<dt><code>CHAR* Alias</code></dt>
<dd>A short name for the driver, without spaces, usually never more
than 10 characters.</dd>
</dl>
<h3>Modules</h3>
<p>The <code>MODULE</code> structure gathers all the necessary
information needed to play a module file, regardless of its initial
format.</p>
<h4>General Module Information</h4>
<p>The fields described in this section contain general information
about the module and should not be modified.</p>
<dl>
<dt><code>CHAR* songname</code></dt>
<dd>Name of the module.<br /></dd>
<dt><code>CHAR* modtype</code></dt>
<dd>Type of the module (which tracker format).<br /></dd>
<dt><code>CHAR* comment</code></dt>
<dd>Either the module comments, or NULL if the module doesn't have
comments.</dd>
</dl>
<dl>
<dt><code>UWORD flags</code></dt>
<dd>Several module flags or'ed together.
<dl>
<dt><code>UF_ARPMEM</code></dt>
<dd>If set, arpeggio effects have memory.<br /></dd>
<dt><code>UF_BGSLIDES</code></dt>
<dd>If set, volume slide effects continue until a new note or a new
effect is played.<br /></dd>
<dt><code>UF_HIGHBPM</code></dt>
<dd>If set, the module is allowed to have its tempo value (bpm)
over 255.<br /></dd>
<dt><code>UF_INST</code></dt>
<dd>If set, the module has instruments and samples; otherwise, the
module has only samples.<br /></dd>
<dt><code>UF_LINEAR</code></dt>
<dd>If set, slide periods are linear; otherwise, they are
logarithmic.<br /></dd>
<dt><code>UF_NNA</code></dt>
<dd>If set, module uses new note actions (NNA) and the
<code>numvoices</code> field is valid.<br /></dd>
<dt><code>UF_NOWRAP</code></dt>
<dd>If set, pattern break on the last pattern does not continue to
the first pattern.<br /></dd>
<dt><code>UF_S3MSLIDES</code></dt>
<dd>If set, module uses old-S3M style volume slides (slides
processed every tick); otherwise, it uses the standard style
(slides processed every tick except the first).<br /></dd>
<dt><code>UF_XMPERIODS</code></dt>
<dd>If set, module uses XM-type periods; otherwise, it uses Amiga
periods.<br /></dd>
<dt><code>UF_FT2QUIRKS</code></dt>
<dd>If set, module player will reproduce some FastTracker 2 quirks
during playback.<br /></dd>
<dt><code>UF_PANNING</code></dt>
<dd>If set, module use panning commands.</dd>
</dl>
<br /></dd>
<dt><code>UBYTE numchn</code></dt>
<dd>The number of channels in the module.<br /></dd>
<dt><code>UBYTE numvoices</code></dt>
<dd>If the module uses NNA, and this variable is not zero, it
contains the limit of module voices; otherwise, the limit is set to
the <code>maxchan</code> parameter of the
<code>Player_Loadxx</code> functions.<br /></dd>
<dt><code>UWORD numpos</code></dt>
<dd>The number of sound positions in the module.<br /></dd>
<dt><code>UWORD numpat</code></dt>
<dd>The number of patterns.<br /></dd>
<dt><code>UWORD numins</code></dt>
<dd>The number of instruments.<br /></dd>
<dt><code>UWORD numsmp</code></dt>
<dd>The number of samples.</dd>
</dl>
<dl>
<dt><code>INSTRUMENT* instruments</code></dt>
<dd>Points to an array of instrument structures.<br /></dd>
<dt><code>SAMPLE* samples</code></dt>
<dd>Points to an array of sample structures.</dd>
</dl>
<dl>
<dt><code>UBYTE realchn</code></dt>
<dd>During playback, this variable contains the number of active
channels (not counting NNA channels).<br /></dd>
<dt><code>UBYTE totalchn</code></dt>
<dd>During playback, this variable contains the total number of
channels (including NNA channels).<br /></dd>
<dt><code>ULONG sngtime</code></dt>
<dd>Elapsed song time, in 2^-10 seconds units (not exactly a
millisecond). To convert this value to seconds, divide by 1024, not
1000 !</dd>
</dl>
<h4>Playback Settings</h4>
<p>The fields described here control the module playback and can be
modified at any time, unless otherwise specified.</p>
<dl>
<dt><code>UBYTE initspeed</code></dt>
<dd>The initial speed of the module (Protracker compatible). Valid
range is 1-32.<br /></dd>
<dt><code>UBYTE inittempo</code></dt>
<dd>The initial tempo of the module (Protracker compatible). Valid
range is 32-255.<br /></dd>
<dt><code>UBYTE initvolume</code></dt>
<dd>The initial overall volume of the module. Valid range is
0-128.<br /></dd>
<dt><code>UWORD panning[]</code></dt>
<dd>The current channel panning positions. Only the first
<code>numchn</code> values are defined.<br /></dd>
<dt><code>UBYTE chanvol[]</code></dt>
<dd>The current channel volumes. Only the first <code>numchn</code>
values are defined.<br /></dd>
<dt><code>UWORD bpm</code></dt>
<dd>The current tempo of the module. Use
<code>Player_SetTempo</code> to change its value.<br /></dd>
<dt><code>UBYTE sngspd</code></dt>
<dd>The current speed of the module. Use
<code>Player_SetSpeed</code> to change its value.<br /></dd>
<dt><code>UBYTE volume</code></dt>
<dd>The current overall volume of the module, in range 0-128. Use
<code>Player_SetVolume</code> to change its value.</dd>
</dl>
<dl>
<dt><code>BOOL extspd</code></dt>
<dd>If zero, Protracker extended speed effect (in-module tempo
modification) is not processed. The default value is 1, which
causes this effect to be processed. However, some old modules might
not play correctly if this effect is not neutralized.<br /></dd>
<dt><code>BOOL panflag</code></dt>
<dd>If zero, panning effects are not processed. The default value
is 1, which cause all panning effects to be processed. However,
some old modules might not play correctly if panning is not
neutralized.<br /></dd>
<dt><code>BOOL wrap</code></dt>
<dd>If nonzero, module wraps to its restart position when it is
finished, to play continuously. Default value is zero (play only
once).<br /></dd>
<dt><code>UBYTE reppos</code></dt>
<dd>The restart position of the module, when it wraps.<br /></dd>
<dt><code>BOOL loop</code></dt>
<dd>If nonzero, all in-module loops are processed; otherwise,
backward loops which decrease the current position are not
processed (i.e. only forward loops, and backward loops in the same
pattern, are processed). This ensures that the module never loops
endlessly. The default value is 1 (all loops are
processed).<br /></dd>
<dt><code>BOOL fadeout</code></dt>
<dd>If nonzero, volume fades out during when last position of the
module is being played. Default value us zero (no fadeout).</dd>
</dl>
<dl>
<dt><code>UWORD patpos</code></dt>
<dd>Current position (row) in the pattern being played. Must not be
changed.<br /></dd>
<dt><code>SWORD sngpos</code></dt>
<dd>Current song position. Do not change this variable directly,
use <code>Player_NextPosition</code>,
<code>Player_PrevPosition</code> or <code>Player_SetPosition</code>
instead.</dd>
</dl>
<dl>
<dt><code>SWORD relspd</code></dt>
<dd>Relative playback speed. The value of this variable is added to
the module tempo to define the actual playback speed. The default
value is 0, which make modules play at their intended speed.</dd>
</dl>
<h3>Module Instruments</h3>
<p>Although the <code>INSTRUMENT</code> structure is intended for
internal use, you might need to know its name:</p>
<dl>
<dt><code>CHAR* insname</code></dt>
<dd>The instrument text, theoretically its name, but often a
message line.</dd>
</dl>
<h3>Samples</h3>
<p>The <code>SAMPLE</code> structure is used for sound effects and
module samples as well. You can play with the following fields:</p>
<dl>
<dt><code>SWORD panning</code></dt>
<dd>Panning value of the sample. Valid values range from PAN_LEFT
(0) to PAN_RIGHT (255), or PAN_SURROUND.<br /></dd>
<dt><code>ULONG speed</code></dt>
<dd>Playing frequency of the sample, it hertz.<br /></dd>
<dt><code>UBYTE volume</code></dt>
<dd>Sample volume. Valid range is 0-64.<br /></dd>
<dt><code>UWORD flags</code></dt>
<dd>Several format flags or'ed together describing the format of
the sample in memory.
<p>Format flags:</p>
<dl>
<dt><code>SF_16BITS</code></dt>
<dd>If set, sample data is 16 bit wide; otherwise, it is 8 bit
wide.<br /></dd>
<dt><code>SF_BIG_ENDIAN</code></dt>
<dd>If set, sample data is in big-endian (Motorola) format;
otherwise, it is in little-endian (Intel) format.<br /></dd>
<dt><code>SF_DELTA</code></dt>
<dd>If set, sample is stored as delta values (differences between
two consecutive samples); otherwise, sample is stored as sample
values.<br /></dd>
<dt><code>SF_ITPACKED</code></dt>
<dd>If set, sample data is packed with Impulse Tracker's
compression method; otherwise, sample is not packed.<br /></dd>
<dt><code>SF_SIGNED</code></dt>
<dd>If set, sample data is made of signed values; otherwise, it is
made of unsigned values.<br /></dd>
<dt><code>SF_STEREO</code></dt>
<dd>If set, sample data is stereo (two channels); otherwise, it is
mono.</dd>
</dl>
<br />
Playback flags:
<dl>
<dt><code>SF_BIDI</code></dt>
<dd>If set, sample loops "ping pong" (back and forth).<br /></dd>
<dt><code>SF_LOOP</code></dt>
<dd>If set, sample loops forward.<br /></dd>
<dt><code>SF_REVERSE</code></dt>
<dd>If set, sample plays backwards.</dd>
</dl>
<br /></dd>
<dt><code>UWORD inflags</code></dt>
<dd>Same as "flags", but describing the format of the sample on
disk.<br /></dd>
<dt><code>ULONG length</code></dt>
<dd>Length of the sample, in <em>samples</em>. The length of a
sample is 8 bits (1 byte) for a 8 bit sample, and 16 bits (2 bytes)
for a 16 bit sample.<br /></dd>
<dt><code>ULONG loopstart</code></dt>
<dd>Loop starting position, relative to the start of the sample, in
samples.<br /></dd>
<dt><code>ULONG loopend</code></dt>
<dd>Loop ending position, relative to the start of the sample, in
samples.</dd>
</dl>
<h3>MREADER</h3>
<p>The <code>MREADER</code> contains the following function
pointers:</p>
<dl>
<dt><code>BOOL (*Seek)(struct MREADER*, long offset, int
whence)</code></dt>
<dd>This function should have the same behaviour as
<code>fseek</code>, with offset 0 meaning the start of the object
(module, sample) being loaded.<br /></dd>
<dt><code>long (*Tell)(struct MREADER*)</code></dt>
<dd>This function should have the same behaviour as
<code>ftell</code>, with offset 0 meaning the start of the object
being loaded.<br /></dd>
<dt><code>BOOL (*Read)(struct MREADER*, void *dest, size_t
length)</code></dt>
<dd>This function should copy <code>length</code> bytes of data
into <code>dest</code>, and return zero if an error occured, and
any nonzero value otherwise. Note that an end-of-file condition
will not be considered as an error in this case.<br /></dd>
<dt><code>int (*Get)(struct MREADER*)</code></dt>
<dd>This function should have the same behaviour as
<code>fgetc</code>.<br /></dd>
<dt><code>BOOL (*Eof)(struct MREADER*)</code></dt>
<dd>This function should have the same behaviour as
<code>feof</code>.</dd>
</dl>
<p>For an example of how to build an <code>MREADER</code> object,
please refer to the <code>MFILEREADER</code> object in file
<code>mmio/mmio.c</code> in the library sources.</p>
<h3>MWRITER</h3>
<p>The <code>MREADER</code> contains the following function
pointers:</p>
<dl>
<dt><code>BOOL (*Seek)(struct MWRITER*, long offset, int
whence);</code></dt>
<dd>This function should have the same behaviour as
<code>fseek</code>, with offset 0 meaning the start of the object
being written.<br /></dd>
<dt><code>long (*Tell)(struct MWRITER*);</code></dt>
<dd>This function should have the same behaviour as
<code>ftell</code>, with offset 0 meaning the start of the object
being written.<br /></dd>
<dt><code>BOOL (*Write)(struct MWRITER*, void *dest, size_t
length);</code></dt>
<dd>This function should copy <code>length</code> bytes of data
from <code>dest</code>, and return zero if an error occured, and
any nonzero value otherwise.<br /></dd>
<dt><code>BOOL (*Put)(struct MWRITER*, int data);</code></dt>
<dd>This function should have the same behaviour as
<code>fputc</code>.</dd>
</dl>
<p>For an example of how to build an <code>MWRITER</code> object,
please refer to the <code>MFILEWRITER</code> object in file
<code>mmio/mmio.c</code> in the library sources.</p>
<hr />
Node:<a name="Error_Reference">Error Reference</a>, Next:<a rel=
"next" href="#Function_Reference">Function Reference</a>,
Previous:<a rel="previous" href="#Structure_Reference">Structure
Reference</a>, Up:<a rel="up" href="#Library_Reference">Library
Reference</a><br />
<h2>Error Reference</h2>
<p>The following errors are currently defined:</p>
<h3>General Errors</h3>
<dl>
<dt><code>MMERR_DYNAMIC_LINKING</code></dt>
<dd>This error occurs when a specific driver was requested, but the
support shared library couldn't be loaded. Currently, the only
drivers which can yield this error are the ALSA, EsounD and Ultra
drivers.<br /></dd>
<dt><code>MMERR_OPENING_FILE</code></dt>
<dd>This error occurs when a file can not be opened, either for
read access from a <code>xx_Loadxx</code> function, or for write
access from the disk writer drivers.<br /></dd>
<dt><code>MMERR_OUT_OF_MEMORY</code></dt>
<dd>This error occurs when there is not enough virtual memory
available to complete the operation, or there is enough memory but
the calling process would exceed its memory limit. MikMod does not
do any resource tuning, your program has to use the
<code>setrlimit</code> function to do this if it needs to load very
huge samples.</dd>
</dl>
<h3>Sample Errors</h3>
<dl>
<dt><code>MMERR_SAMPLE_TOO_BIG</code></dt>
<dd>This error occurs when the memory allocation of the sample data
yields the error <code>MMERR_OUT_OF_MEMORY</code>.<br /></dd>
<dt><code>MMERR_OUT_OF_HANDLES</code></dt>
<dd>This error occurs when your program reaches the limit of loaded
samples, currently defined as 384, which should be sufficient for
most cases.<br /></dd>
<dt><code>MMERR_UNKNOWN_WAVE_TYPE</code></dt>
<dd>This error occurs when you're trying to load a sample which
format is not recognized.</dd>
</dl>
<h3>Module Errors</h3>
<dl>
<dt><code>MMERR_ITPACK_INVALID_DATA</code></dt>
<dd>This error occurs when a compressed module sample is
corrupt.<br /></dd>
<dt><code>MMERR_LOADING_HEADER</code></dt>
<dd>This error occurs when you're trying to load a module which has
a corrupted header, or is truncated.<br /></dd>
<dt><code>MMERR_LOADING_PATTERN</code></dt>
<dd>This error occurs when you're trying to load a module which has
corrupted pattern data, or is truncated.<br /></dd>
<dt><code>MMERR_LOADING_SAMPLEINFO</code></dt>
<dd>This error occurs when you're trying to load a module which has
corrupted sample information, or is truncated.<br /></dd>
<dt><code>MMERR_LOADING_TRACK</code></dt>
<dd>This error occurs when you're trying to load a module which has
corrupted track data, or is truncated.<br /></dd>
<dt><code>MMERR_MED_SYNTHSAMPLES</code></dt>
<dd>This error occurs when you're trying to load a MED module which
has synthsounds samples, which are currently not supported.<a rel=
"footnote" href="#fn-3"><sup>3</sup></a><br /></dd>
<dt><code>MMERR_NOT_A_MODULE</code></dt>
<dd>This error occurs when you're trying to load a module which
format is not recognized.<br /></dd>
<dt><code>MMERR_NOT_A_STREAM</code></dt>
<dd>This error occurs when you're trying to load a sample with a
sample which format is not recognized.</dd>
</dl>
<h3>Driver Errors</h3>
<h4>Generic Driver Errors</h4>
<dl>
<dt><code>MMERR_16BIT_ONLY</code></dt>
<dd>This error occurs when the sound device doesn't support non-16
bit linear sound output, which are the requested
settings.<br /></dd>
<dt><code>MMERR_8BIT_ONLY</code></dt>
<dd>This error occurs when the sound device doesn't support non-8
bit linear sound output, which are the requested
settings.<br /></dd>
<dt><code>MMERR_DETECTING_DEVICE</code></dt>
<dd>This error occurs when the driver's sound device has not been
detected.<br /></dd>
<dt><code>MMERR_INITIALIZING_MIXER</code></dt>
<dd>This error occurs when MikMod's internal software mixer could
not be initialized properly.<br /></dd>
<dt><code>MMERR_INVALID_DEVICE</code></dt>
<dd>This error occurs when the driver number (in
<code>md_device</code>) is out of range.<br /></dd>
<dt><code>MMERR_NON_BLOCK</code></dt>
<dd>This error occurs when the driver is unable to set the audio
device in non blocking mode.<br /></dd>
<dt><code>MMERR_OPENING_AUDIO</code></dt>
<dd>This error occurs when the driver can not open sound
device.<br /></dd>
<dt><code>MMERR_STEREO_ONLY</code></dt>
<dd>This error occurs when the sound device doesn't support mono
sound output, which is the requested setting.<br /></dd>
<dt><code>MMERR_ULAW</code></dt>
<dd>This error occurs when the sound device only supports uLaw
output (which implies mono, 8 bit, and 8000 Hz sampling rate),
which isn't the requested setting.</dd>
</dl>
<h4>AudioFile Driver Specific Error</h4>
<dl>
<dt><code>MMERR_AF_AUDIO_PORT</code></dt>
<dd>This error occurs when the AudioFile driver can not find a
suitable AudioFile port.</dd>
</dl>
<h4>AIX Driver Specific Errors</h4>
<dl>
<dt><code>MMERR_AIX_CONFIG_CONTROL</code></dt>
<dd>This error occurs when the "Control" step of the device
configuration has failed.<br /></dd>
<dt><code>MMERR_AIX_CONFIG_INIT</code></dt>
<dd>This error occurs when the "Init" step of the device
configuration has failed.<br /></dd>
<dt><code>MMERR_AIX_CONFIG_START</code></dt>
<dd>This error occurs when the "Start" step of the device
configuration has failed.</dd>
</dl>
<h4>Ultra Driver Specific Errors</h4>
<dl>
<dt><code>MMERR_GUS_RESET</code></dt>
<dd>This error occurs when the sound device couldn't be
reset.<br /></dd>
<dt><code>MMERR_GUS_SETTINGS</code></dt>
<dd>This error occurs because the sound device only works in 16 bit
linear stereo sound at 44100 Hz, which is not the requested
settings.<br /></dd>
<dt><code>MMERR_GUS_TIMER</code></dt>
<dd>This error occurs when the ultra driver could not setup the
playback timer.</dd>
</dl>
<h4>HP-UX Driver Specific Errors</h4>
<dl>
<dt><code>MMERR_HP_AUDIO_DESC</code></dt>
<dd>This error occurs when the HP driver can not get the audio
hardware description.<br /></dd>
<dt><code>MMERR_HP_AUDIO_OUTPUT</code></dt>
<dd>This error occurs when the HP driver can not select the audio
output.<br /></dd>
<dt><code>MMERR_HP_BUFFERSIZE</code></dt>
<dd>This error occurs when the HP driver can not set the
transmission buffer size.<br /></dd>
<dt><code>MMERR_HP_CHANNELS</code></dt>
<dd>This error occurs when the HP driver can not set the requested
number of channels.<br /></dd>
<dt><code>MMERR_HP_SETSAMPLESIZE</code></dt>
<dd>This error occurs when the HP driver can not set the requested
sample size.<br /></dd>
<dt><code>MMERR_HP_SETSPEED</code></dt>
<dd>This error occurs when the HP driver can not set the requested
sample rate.</dd>
</dl>
<h4>Open Sound System Driver Specific Errors</h4>
<dl>
<dt><code>MMERR_OSS_SETFRAGMENT</code></dt>
<dd>This error occurs when the OSS driver can not set audio
fragment size.<br /></dd>
<dt><code>MMERR_OSS_SETSAMPLESIZE</code></dt>
<dd>This error occurs when the OSS driver can not set the requested
sample size.<br /></dd>
<dt><code>MMERR_OSS_SETSPEED</code></dt>
<dd>This error occurs when the OSS driver can not set the requested
sample rate.<br /></dd>
<dt><code>MMERR_OSS_SETSTEREO</code></dt>
<dd>This error occurs when the OSS driver can not set the requested
number of channels.</dd>
</dl>
<h4>SGI Driver Specific Errors</h4>
<dl>
<dt><code>MMERR_SGI_MONO</code></dt>
<dd>This error occurs when the hardware only supports stereo
sound.<br /></dd>
<dt><code>MMERR_SGI_SPEED</code></dt>
<dd>This error occurs when the hardware does not support the
requested sample rate.<br /></dd>
<dt><code>MMERR_SGI_STEREO</code></dt>
<dd>This error occurs when the hardware only supports mono
sound.<br /></dd>
<dt><code>MMERR_SGI_16BIT</code></dt>
<dd>This error occurs when the hardware only supports 16 bit
sound.<br /></dd>
<dt><code>MMERR_SGI_8BIT</code></dt>
<dd>This error occurs when the hardware only supports 8 bit
sound.</dd>
</dl>
<h4>Sun Driver Specific Error</h4>
<dl>
<dt><code>MMERR_SUN_INIT</code></dt>
<dd>This error occurs when the sound device initialization
failed.</dd>
</dl>
<h4>OS/2 Driver Specific Errors</h4>
<dl>
<dt><code>MMERR_OS2_MIXSETUP</code></dt>
<dd>This error occurs when the DART driver can not set the mixing
parameters.<br /></dd>
<dt><code>MMERR_OS2_SEMAPHORE</code></dt>
<dd>This error occurs when the MMPM/2 driver can not create the
semaphores needed for playback.<br /></dd>
<dt><code>MMERR_OS2_THREAD</code></dt>
<dd>This error occurs when the MMPM/2 driver can not create the
thread needed for playback.<br /></dd>
<dt><code>MMERR_OS2_TIMER</code></dt>
<dd>This error occurs when the MMPM/2 driver can not create the
timer needed for playback.</dd>
</dl>
<h4>DirectX Driver Specific Errors</h4>
<dl>
<dt><code>MMERR_DS_BUFFER</code></dt>
<dd>This error occurs when the DirectX driver can not allocate the
playback buffers.<br /></dd>
<dt><code>MMERR_DS_EVENT</code></dt>
<dd>This error occurs when the DirectX driver can not register the
playback event.<br /></dd>
<dt><code>MMERR_DS_FORMAT</code></dt>
<dd>This error occurs when the DirectX driver can not set the
playback format.<br /></dd>
<dt><code>MMERR_DS_NOTIFY</code></dt>
<dd>This error occurs when the DirectX driver can not register the
playback callback.<br /></dd>
<dt><code>MMERR_DS_PRIORITY</code></dt>
<dd>This error occurs when the DirectX driver can not set the
playback priority.<br /></dd>
<dt><code>MMERR_DS_THREAD</code></dt>
<dd>This error occurs when the DirectX driver can not create the
playback thread.<br /></dd>
<dt><code>MMERR_DS_UPDATE</code></dt>
<dd>This error occurs when the DirectX driver can not initialize
the playback thread.</dd>
</dl>
<h4>Windows Multimedia API Driver Specific Errors</h4>
<dl>
<dt><code>MMERR_WINMM_ALLOCATED</code></dt>
<dd>This error occurs when the playback resource is already
allocated by another application.<br /></dd>
<dt><code>MMERR_WINMM_DEVICEID</code></dt>
<dd>This error occurs when the Multimedia API Driver is given an
invalid audio device identificator.<br /></dd>
<dt><code>MMERR_WINMM_FORMAT</code></dt>
<dd>This error occurs when the playback output format is not
supported by the audio device.<br /></dd>
<dt><code>MMERR_WINMM_HANDLE</code></dt>
<dd>This error occurs when the Multimedia API Driver is given an
invalid handle.<br /></dd>
<dt><code>MMERR_WINMM_UNKNOWN</code></dt>
<dd>This error should not occur ! If you get this error, please
contact the libmikmod development mailing list.</dd>
</dl>
<h4>MacOS Driver Specific Errors</h4>
<dl>
<dt><code>MMERR_MAC_SPEED</code></dt>
<dd>This error occurs when the playback speed is not supported by
the audio device.<br /></dd>
<dt><code>MMERR_MAC_START</code></dt>
<dd>This error occurs when the MacOS driver can not start
playback.</dd>
</dl>
<hr />
Node:<a name="Function_Reference">Function Reference</a>,
Next:<a rel="next" href="#Library_Core_Functions">Library Core
Functions</a>, Previous:<a rel="previous" href=
"#Error_Reference">Error Reference</a>, Up:<a rel="up" href=
"#Library_Reference">Library Reference</a><br />
<h2>Function Reference</h2>
<ul>
<li><a href="#Library_Core_Functions">Library Core
Functions</a>: MikMod_xx functions.</li>
<li><a href="#Module_Player_Functions">Module Player
Functions</a>: Player_xx functions.</li>
<li><a href="#Sample_Functions">Sample Functions</a>: Sample_xx
functions.</li>
<li><a href="#Voice_Functions">Voice Functions</a>: Voice_xx
functions.</li>
</ul>
<hr />
Node:<a name="Library_Core_Functions">Library Core
Functions</a>, Next:<a rel="next" href=
"#Module_Player_Functions">Module Player Functions</a>,
Previous:<a rel="previous" href="#Function_Reference">Function
Reference</a>, Up:<a rel="up" href="#Function_Reference">Function
Reference</a><br />
<h3>Library Core Functions</h3>
<h4>MikMod_Active</h4>
<p><code>BOOL MikMod_Active(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function returns whether sound output is enabled or
not.<br /></dd>
<dt><i>Result</i></dt>
<dt><i>0</i></dt>
<dd>Sound output is disabled.<br /></dd>
<dt><i>1</i></dt>
<dd>Sound output is enabled.<br /></dd>
<dt><i>Notes</i></dt>
<dd>Calls to <code>MikMod_Update</code> will be ignored when sound
output is disabled.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>MikMod_DisableOutput</code>,
<code>MikMod_EnableOutput</code>.</dd>
</dl>
<h4>MikMod_DisableOutput</h4>
<p><code>void MikMod_DisableOutput(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function stops the sound mixing.<br /></dd>
<dt><i>Notes</i></dt>
<dd>Calls to <code>MikMod_Update</code> will be ignored when sound
output is disabled.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>MikMod_Active</code>,
<code>MikMod_EnableOutput</code>.</dd>
</dl>
<h4>MikMod_EnableOutput</h4>
<p><code>BOOL MikMod_EnableOutput(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function starts the sound mixing.<br /></dd>
<dt><i>Result</i></dt>
<dt><i>0</i></dt>
<dd>Sound mixing is ready.</dd>
<dt><i>nonzero</i></dt>
<dd>An error occurred during the operation.<br /></dd>
<dt><i>Notes</i></dt>
<dd>Calls to <code>MikMod_Update</code> will be ignored when sound
output is disabled.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>MikMod_Active</code>,
<code>MikMod_DisableOutput</code>.</dd>
</dl>
<h4>MikMod_Exit</h4>
<p><code>void MikMod_Exit(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function deinitializes the sound hardware and frees all
the memory and resources used by MikMod.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>MikMod_Init</code>, <code>MikMod_Reset</code>.</dd>
</dl>
<h4>MikMod_GetVersion</h4>
<p><code>long MikMod_GetVersion(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function returns the version number of the
library.<br /></dd>
<dt><i>Result</i></dt>
<dd>The version number, encoded as follows:
<code>(maj&lt;&lt;16)|(min&lt;&lt;8)|(rev)</code>, where
<code>maj</code> is the major version number, <code>min</code> is
the minor version number, and <code>rev</code> is the revision
number.</dd>
</dl>
<h4>MikMod_InfoDriver</h4>
<p><code>CHAR* MikMod_InfoDriver(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function returns a formatted list of the registered
drivers in a buffer.<br /></dd>
<dt><i>Result</i></dt>
<dd>A pointer to a text buffer, or <code>NULL</code> if no drivers
are registered.<br /></dd>
<dt><i>Notes</i></dt>
<dd>The buffer is created with <code>malloc</code>; the caller must
free it when it is no longer necessary.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>MikMod_RegisterDriver</code>,
<code>MikMod_RegisterAllDrivers</code>.</dd>
</dl>
<h4>MikMod_InfoLoader</h4>
<p><code>CHAR* MikMod_InfoLoader(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function returns a formatted list of the registered module
loaders in a buffer.<br /></dd>
<dt><i>Result</i></dt>
<dd>A pointer to a text buffer, or <code>NULL</code> if no loaders
are registered.<br /></dd>
<dt><i>Notes</i></dt>
<dd>The buffer is created with <code>malloc</code>; the caller must
free it when it is no longer necessary.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>MikMod_RegisterLoader</code>,
<code>MikMod_RegisterAllLoaders</code>.</dd>
</dl>
<h4>MikMod_Init</h4>
<p><code>BOOL MikMod_Init(CHAR *parameters)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function performs the library initialization, including
the sound driver choice and configuration, and all the necessary
memory allocations.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>parameters</i></dt>
<dd>Optional parameters given to the sound driver. These parameters
are ignored if the value of <code>md_device</code> is zero
(autodetection).<br /></dd>
<dt><i>Result</i></dt>
<dt><i>0</i></dt>
<dd>Initialization was successful.</dd>
<dt><i>nonzero</i></dt>
<dd>An error occurred during initialization.<br /></dd>
<dt><i>Notes</i></dt>
<dd>When the initialization fails, the library uses the nosound
sound driver to let other the other MikMod functions work without
crashing the application.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>MikMod_Exit</code>, <code>MikMod_InitThreads</code>,
<code>MikMod_Reset</code>.</dd>
</dl>
<h4>MikMod_InitThreads</h4>
<p><code>BOOL MikMod_InitThreads(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function returns whether libmikmod is
thread-safe.<br /></dd>
<dt><i>Result</i></dt>
<dt><i>0</i></dt>
<dd>The library is not thread-safe.</dd>
<dt><i>1</i></dt>
<dd>The library is thread-safe.<br /></dd>
<dt><i>Notes</i></dt>
<dd>This function should be called before any call to
<code>MikMod_Lock</code> or <code>MikMod_Unlock</code> is
made.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>MikMod_Lock</code>, <code>MikMod_Unlock</code>.</dd>
</dl>
<h4>MikMod_Lock</h4>
<p><code>void MikMod_Lock(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function obtains exclusive access to libmikmod's
variables.<br /></dd>
<dt><i>Notes</i></dt>
<dd>This function locks an internal mutex. If the mutex is already
locked, it will block the calling thread until the mutex is
unlocked.<br />
Every <code>MikMod_Unlock</code> call should be associated to a
<code>MikMod_Lock</code> call. To be sure this is the case, we
advise you to define and use the following macros:<br />
<code>#define MIKMOD_LOCK MikMod_Lock();{</code><br />
<code>#define MIKMOD_UNLOCK }MikMod_Unlock();</code><br />
The function <code>MikMod_InitThreads</code> must have been invoked
before any call to <code>MikMod_Lock</code> in made.<br />
<br /></dd>
<dt><i>See also</i></dt>
<dd><code>MikMod_InitThreads</code>,
<code>MikMod_Unlock</code>.</dd>
</dl>
<h4>MikMod_RegisterAllDrivers</h4>
<p><code>void MikMod_RegisterAllDrivers(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function registers all the available drivers.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>MikMod_InfoDriver</code>,
<code>MikMod_RegisterDriver</code>.</dd>
</dl>
<h4>MikMod_RegisterAllLoaders</h4>
<p><code>void MikMod_RegisterAllLoaders(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function registers all the available module
loaders.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>MikMod_InfoLoader</code>,
<code>MikMod_RegisterLoader</code>.</dd>
</dl>
<h4>MikMod_RegisterDriver</h4>
<p><code>void MikMod_RegisterDriver(struct MDRIVER*
newdriver)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function adds the specified driver to the internal list of
usable drivers.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>newdriver</i></dt>
<dd>A pointer to the <code>MDRIVER</code> structure identifying the
driver.<br /></dd>
<dt><i>Notes</i></dt>
<dd>It is safe to register the same driver several times, although
it will not be duplicated in the list.<br />
You should register all the drivers you need before calling
<code>MikMod_Init</code>. If you want to register all the available
drivers, use <code>MikMod_RegisterAllDrivers</code>
instead.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>MikMod_InfoDriver</code>,
<code>MikMod_RegisterAllDrivers</code>.</dd>
</dl>
<h4>MikMod_RegisterErrorHandler</h4>
<p><code>MikMod_handler_t
MikMod_RegisterErrorHandler(MikMod_handler_t newhandler)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function selects the function which should be called in
case of error.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>newhandler</i></dt>
<dd>The new error callback function.<br /></dd>
<dt><i>Result</i></dt>
<dd>The previous error callback function, or <code>NULL</code> if
there was none.<br /></dd>
<dt><i>Notes</i></dt>
<dd><code>MikMod_handler_t</code> is defined as
<code>void(*function)(void)</code>, this means your error function
has the following prototype: <code>void
MyErrorHandler(void)</code><br />
The error callback function is called when errors are detected, but
not always immediately (the library has to resume to a stable state
before calling your callback).</dd>
</dl>
<h4>MikMod_RegisterLoader</h4>
<p><code>void MikMod_RegisterLoader(struct MLOADER*
newloader)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function adds the specified module loader to the internal
list of usable module loaders.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>newloader</i></dt>
<dd>A pointer to the <code>MLOADER</code> structure identifying the
loader.<br /></dd>
<dt><i>Notes</i></dt>
<dd>It is safe to register the same loader several times, although
it will not be duplicated in the list.<br />
You should register all the loaders you need before calling
<code>Player_Load</code> or <code>Player_LoadFP</code>. If you want
to register all the available module loaders, use
<code>MikMod_RegisterAllLoaders</code> instead.<br />
The 15 instrument module loader (<code>load_m15</code>) should
always be registered last.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>MikMod_InfoLoader</code>,
<code>MikMod_RegisterAllLoaders</code>.</dd>
</dl>
<h4>MikMod_RegisterPlayer</h4>
<p><code>MikMod_player_t MikMod_RegisterPlayer(MikMod_player_t
newplayer)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function selects the function which should be used to
process module playback.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>newplayer</i></dt>
<dd>The new playback function<br /></dd>
<dt><i>Result</i></dt>
<dd>The previous playback function.<br /></dd>
<dt><i>Notes</i></dt>
<dd><code>MikMod_player_t</code> is defined as
<code>void(*function)(void)</code>, this means your player function
has the following prototype: <code>void MyPlayer(void)</code><br />
The player function is called every module tick to process module
playback. The rate at which the player function is called is
controlled by the sound driver, and is computed by the following
equation:<br />
(bpm*50)/125 calls per second, which means every 125000/(bpm*50)
milliseconds. The <code>bpm</code> value is the tempo of the module
and can change from its initial value when requested by the
module.<br />
When changing the playback function, you should make sure that you
chain to the default MikMod playback function, otherwise you won't
get module sound anymore….<br /></dd>
<dt><i>Example</i></dt>
<dd>
<pre>
    MikMod_player_t oldroutine;

    void MyPlayer(void)
    {
        oldroutine();
        /* your stuff here */
        …
    }

    main()
    {
        …
        /* Register our player */
        oldroutine = MikMod_RegisterPlayer(MyPlayer);
        …
    }
</pre></dd>
</dl>
<h4>MikMod_Reset</h4>
<p><code>BOOL MikMod_Reset(CHAR *parameters)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function resets MikMod and reinitialize the sound
hardware.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>parameters</i></dt>
<dd>Optional parameters given to the sound driver. If you set the
value of <code>md_device</code> to zero (autodetect), these
parameters are ignored.<br /></dd>
<dt><i>Result</i></dt>
<dt><i>0</i></dt>
<dd>Reinitialization was successful.</dd>
<dt><i>nonzero</i></dt>
<dd>An error occurred during reinitialization.<br /></dd>
<dt><i>Notes</i></dt>
<dd>Use this function when you have changed the global
configuration variables: <code>md_device</code> and
<code>md_mixfreq</code>, or one of the <code>md_mode</code> flags
which require sound reinitialization. Sound playback will continue
as soon as the driver is ready.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>MikMod_Exit</code>, <code>MikMod_Init</code>.</dd>
</dl>
<h4>MikMod_SetNumVoices</h4>
<p><code>BOOL MikMod_SetNumVoices(int musicvoices, int
samplevoices)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function sets the number of mixed voices which can be used
for music and sound effects playback.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>musicvoices</i></dt>
<dd>The number of voices to reserve for music playback.<br /></dd>
<dt><i>samplevoices</i></dt>
<dd>The number of voices to reserve for sound effects.<br /></dd>
<dt><i>Result</i></dt>
<dt><i>0</i></dt>
<dd>Initialization was successful.</dd>
<dt><i>nonzero</i></dt>
<dd>An error occurred during initialization.<br /></dd>
<dt><i>Notes</i></dt>
<dd>A value of <code>-1</code> for any of the parameters will
retain the current number of reserved voices.<br />
The maximum number of voices vary from driver to driver (hardware
drivers often have a limit of 32 to 64 voices, whereas the software
drivers handle 255 voices). If your settings exceed the driver's
limit, they will be truncated.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>MikMod_Init</code>, <code>MikMod_Reset</code>.</dd>
</dl>
<h4>MikMod_Unlock</h4>
<p><code>void MikMod_Unlock(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function relinquishes exclusive access to libmikmod's
variables.<br /></dd>
<dt><i>Notes</i></dt>
<dd>This function unlocks an internal mutex, so that other threads
waiting for the lock can be resumed.<br />
Every <code>MikMod_Unlock</code> call should be associated to a
<code>MikMod_Lock</code> call. To be sure this is the case, we
advise you to define and use the following macros:<br />
<code>#define MIKMOD_LOCK MikMod_Lock();{</code><br />
<code>#define MIKMOD_UNLOCK }MikMod_Unlock();</code><br />
The function <code>MikMod_InitThreads</code> must have been invoked
before any call to <code>MikMod_Unlock</code> in made.<br />
<br /></dd>
<dt><i>See also</i></dt>
<dd><code>MikMod_InitThreads</code>, <code>MikMod_Lock</code>.</dd>
</dl>
<h4>MikMod_Update</h4>
<p><code>void MikMod_Update(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This routine should be called on a regular basis to update the
sound.<br /></dd>
<dt><i>Notes</i></dt>
<dd>The sound output buffer is filled each time this function is
called; if you use a large buffer, you don't need to call this
routine as frequently as with a smaller buffer, but you get a
bigger shift between the sound being played and the reported state
of the player, since the player is always a buffer ahead of the
playback.<br />
If you play low quality sound (for example, mono 8 bit 11kHz
sound), you only need to call this routine a few times per second.
However, for high quality sound (stereo 16 bit 44kHz), this rate
increases to a few hundred times per second, but never more, due to
the minimal buffer size constraint imposed to the sound
drivers.<br />
If you plan on modifying voice information with the
<code>Voice_xx</code> functions, you should do this before calling
<code>MikMod_Update</code>.</dd>
</dl>
<h4>MikMod_strerror</h4>
<p><code>char* MikMod_strerror(int errno)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function associates a descriptive message to an error
code.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>errno</i></dt>
<dd>The MikMod error code.<br /></dd>
<dt><i>Result</i></dt>
<dd>A pointer to a string describing the error.</dd>
</dl>
<hr />
Node:<a name="Module_Player_Functions">Module Player
Functions</a>, Next:<a rel="next" href="#Sample_Functions">Sample
Functions</a>, Previous:<a rel="previous" href=
"#Library_Core_Functions">Library Core Functions</a>,
Up:<a rel="up" href="#Function_Reference">Function
Reference</a><br />
<h3>Module Player Functions</h3>
<h4>Player_Active</h4>
<p><code>BOOL Player_Active(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function returns whether the module player is active or
not.<br /></dd>
<dt><i>Result</i></dt>
<dt><i>0</i></dt>
<dd>No module is playing.</dd>
<dt><i>nonzero</i></dt>
<dd>A module is currently playing.<br /></dd>
<dt><i>Notes</i></dt>
<dd>This function will still report that the player is active if
the playing module is paused.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_Paused</code>, <code>Player_TogglePause</code>,
<code>Player_Start</code>, <code>Player_Stop</code></dd>
</dl>
<h4>Player_Free</h4>
<p><code>void Player_Free(MODULE* module)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function stops the module if it is playing and unloads it
from memory.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>module</i></dt>
<dd>The module to free.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_Load</code>, <code>Player_LoadFP</code>.</dd>
</dl>
<h4>Player_GetChannelVoice</h4>
<p><code>int Player_GetChannelVoice(UBYTE channel)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function determines the voice corresponding to the
specified module channel.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>channel</i></dt>
<dd>The module channel to use.<br /></dd>
<dt><i>Result</i></dt>
<dd>The number of the voice corresponding to the module
channel.<br /></dd>
<dt><i>Notes</i></dt>
<dd>If the module channel has NNAs, the number will correspond to
the main channel voice.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Voice_SetPanning</code>, <code>Voice_SetVolume</code>,
<code>Player_Mute</code>, <code>Player_ToggleMute</code>,
<code>Player_Unmute</code>.</dd>
</dl>
<h4>Player_GetModule</h4>
<p><code>MODULE* Player_GetModule(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function returns the module currently being
played.<br /></dd>
<dt><i>Result</i></dt>
<dd>A pointer to the <code>MODULE</code> being played, or
<code>NULL</code> if no module is playing.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_Stop</code>, <code>Player_Start</code>.</dd>
</dl>
<h4>Player_Load</h4>
<p><code>MODULE* Player_Load(CHAR* filename, int maxchan, BOOL
curious)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function loads a music module.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>filename</i></dt>
<dd>The name of the module file.<br /></dd>
<dt><i>maxchan</i></dt>
<dd>The maximum number of channels the song is allowed to request
from the mixer.<br /></dd>
<dt><i>curious</i></dt>
<dd>The curiosity level to use.<br /></dd>
<dt><i>Result</i></dt>
<dd>A pointer to a <code>MODULE</code> structure, or
<code>NULL</code> if an error occurs.<br /></dd>
<dt><i>Notes</i></dt>
<dd>If the curiosity level is set to zero, the module will be
loaded normally. However, if it is nonzero, the following things
occur:
<ul>
<li>pattern positions occurring after the "end of song" marker in
S3M and IT modules are loaded, and the end of song is set to the
last position.</li>
<li>hidden extra patterns are searched in MOD modules, and if
found, played after the last "official" pattern.</li>
<li>MED modules with synthsounds are loaded without causing the
<code>MMERR_MED_SYNTHSAMPLES</code>, and synthsounds are mapped to
an empty sample.</li>
</ul>
<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_Free</code>, <code>Player_LoadFP</code>,
<code>Player_LoadTitle</code>, <code>Player_LoadTitleFP</code>,
<code>Player_Start</code>.</dd>
</dl>
<h4>Player_LoadFP</h4>
<p><code>MODULE* Player_LoadFP(FILE* file, int maxchan, BOOL
curious)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function loads a music module.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>file</i></dt>
<dd>An open file, at the position where the module
starts.<br /></dd>
<dt><i>maxchan</i></dt>
<dd>The maximum number of channels the song is allowed to request
from the mixer.<br /></dd>
<dt><i>curious</i></dt>
<dd>The curiosity level to use.<br /></dd>
<dt><i>Result</i></dt>
<dd>A pointer to a <code>MODULE</code> structure, or
<code>NULL</code> if an error occurs.<br /></dd>
<dt><i>Notes</i></dt>
<dd>The file is left open, at the same position as before the
function call.<br />
If the curiosity level is set to zero, the module will be loaded
normally. However, if it is nonzero, the following things occur:
<ul>
<li>pattern positions occurring after the "end of song" marker in
S3M and IT modules are loaded, and the end of song is set to the
last position.</li>
<li>hidden extra patterns are searched in MOD modules, and if
found, played after the last "official" pattern.</li>
<li>MED modules with synthsounds are loaded without causing the
<code>MMERR_MED_SYNTHSAMPLES</code>, and synthsounds are mapped to
an empty sample.</li>
</ul>
<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_Free</code>, <code>Player_Load</code>,
<code>Player_LoadTitle</code>, <code>Player_LoadTitleFP</code>,
<code>Player_Start</code>.</dd>
</dl>
<h4>Player_LoadTitle</h4>
<p><code>MODULE* Player_LoadTitle(CHAR* filename)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function retrieves the title of a module file.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>filename</i></dt>
<dd>The name of the module file.<br /></dd>
<dt><i>Result</i></dt>
<dd>A pointer to the song title, or <code>NULL</code> if either the
module has no title or an error has occurred.<br /></dd>
<dt><i>Notes</i></dt>
<dd>The title buffer is created with <code>malloc</code>; the
caller must free it when it is no longer necessary.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_Load</code>, <code>Player_LoadFP</code>,
<code>Player_LoadTitleFP</code>.</dd>
</dl>
<h4>Player_LoadTitleFP</h4>
<p><code>MODULE* Player_LoadTitleFP(FILE* file)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function retrieves the title of a module file.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>file</i></dt>
<dd>An open file, at the position where the module
starts.<br /></dd>
<dt><i>Result</i></dt>
<dd>A pointer to the song title, or <code>NULL</code> if either the
module has no title or an error has occurred.<br /></dd>
<dt><i>Notes</i></dt>
<dd>The title buffer is created with <code>malloc</code>; the
caller must free it when it is no longer necessary.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_Load</code>, <code>Player_LoadFP</code>,
<code>Player_LoadTitle</code>.</dd>
</dl>
<h4>Player_Mute</h4>
<p><code>void Player_Mute(SLONG operation, ...)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function mutes a single module channel, or a range of
module channels.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>operation</i></dt>
<dd>Either the number of a module channel to mute (starting from
zero), or an operation code. In the latter case, two extra
parameters are needed to determine the range of
channels.<br /></dd>
<dt><i>Notes</i></dt>
<dd>If the operation is <code>MUTE_INCLUSIVE</code>, the two
channel numbers delimit the range and are part of the range ;
otherwise, if the operation is <code>MUTE_EXCLUSIVE</code>, they
are outside of the range.<br /></dd>
<dt><i>Example</i></dt>
<dd>
<pre>
    /* mute channel 10 */
    Player_Mute(10);
    /* mute channels 2 to 5 */
    Player_Mute(MUTE_INCLUSIVE, 2, 5);
    /* mute channels 7 to 9 */
    Player_Mute(MUTE_EXCLUSIVE, 6, 10);
</pre>
<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_Muted</code>, <code>Player_ToggleMute</code>,
<code>Player_Unmute</code>.</dd>
</dl>
<h4>Player_Muted</h4>
<p><code>BOOL Player_Muted(UBYTE channel)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function determines whether a module channel is muted or
not.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>channel</i></dt>
<dd>The module channel to test (starting from zero).<br /></dd>
<dt><i>Result</i></dt>
<dt><i>0</i></dt>
<dd>The channel is not muted.</dd>
<dt><i>1</i></dt>
<dd>The channel is muted.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_Mute</code>, <code>Player_ToggleMute</code>,
<code>Player_Unmute</code>.</dd>
</dl>
<h4>Player_NextPosition</h4>
<p><code>void Player_NextPosition(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function jumps to the next position in the
module.<br /></dd>
<dt><i>Notes</i></dt>
<dd>All playing samples and active song voices are cut to avoid
hanging notes.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_PrevPosition</code>,
<code>Player_SetPosition</code>.</dd>
</dl>
<h4>Player_Paused</h4>
<p><code>BOOL Player_Paused(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function determines whether the module is paused or
not.<br /></dd>
<dt><i>Result</i></dt>
<dt><i>0</i></dt>
<dd>The module is not paused.<br /></dd>
<dt><i>1</i></dt>
<dd>The module is paused.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_TogglePause</code>.</dd>
</dl>
<h4>Player_PrevPosition</h4>
<p><code>void Player_PrevPosition(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function jumps to the previous position in the
module.<br /></dd>
<dt><i>Notes</i></dt>
<dd>All playing samples and active song voices are cut to avoid
hanging notes.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_NextPosition</code>,
<code>Player_SetPosition</code>.</dd>
</dl>
<h4>Player_SetPosition</h4>
<p><code>void Player_SetPosition(UWORD position)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function jumps to the specified position in the
module.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>position</i></dt>
<dd>The pattern position to jump to.<br /></dd>
<dt><i>Notes</i></dt>
<dd>All playing samples and active song voices are cut to avoid
hanging notes.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_NextPosition</code>,
<code>Player_PrevPosition</code>.</dd>
</dl>
<h4>Player_SetSpeed</h4>
<p><code>void Player_SetSpeed(UWORD speed)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function sets the module speed.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>speed</i></dt>
<dd>The new module speed, in the range 1-32.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_SetTempo</code>.</dd>
</dl>
<h4>Player_SetTempo</h4>
<p><code>void Player_SetTempo(UWORD tempo)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function sets the module tempo.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>tempo</i></dt>
<dd>The new module tempo, in the range 32-255.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_SetSpeed</code>.</dd>
</dl>
<h4>Player_SetVolume</h4>
<p><code>void Player_SetVolume(SWORD volume)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function sets the module volume.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>volume</i></dt>
<dd>The new overall module playback volume, in the range
0-128.</dd>
</dl>
<h4>Player_Start</h4>
<p><code>void Player_Start(MODULE* module)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function starts the specified module playback.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>module</i></dt>
<dd>The module to play.<br /></dd>
<dt><i>Notes</i></dt>
<dd>If another module is playing, it will be stopped and the new
module will play.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_Stop</code>.</dd>
</dl>
<h4>Player_Stop</h4>
<p><code>void Player_Stop(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function stops the currently playing module.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_Start</code>.</dd>
</dl>
<h4>Player_ToggleMute</h4>
<p><code>void Player_ToggleMute(SLONG operation, ...)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function changes the muted status of a single module
channel, or a range of module channels.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>operation</i></dt>
<dd>Either the number of a module channel to work on (starting from
zero), or an operation code. In the latter case, two extra
parameters are needed to determine the range of
channels.<br /></dd>
<dt><i>Notes</i></dt>
<dd>If the operation is <code>MUTE_INCLUSIVE</code>, the two
channel numbers delimit the range and are part of the range ;
otherwise, if the operation is <code>MUTE_EXCLUSIVE</code>, they
are outside of the range.<br /></dd>
<dt><i>Example</i></dt>
<dd>
<pre>
    /* toggle mute on channel 10 */
    Player_ToggleMute(10);
    /* toggle mute on channels 2 to 5 */
    Player_ToggleMute(MUTE_INCLUSIVE, 2, 5);
    /* toggle mute on channels 7 to 9 */
    Player_ToggleMute(MUTE_EXCLUSIVE, 6, 10);
</pre>
<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_Mute</code>, <code>Player_Muted</code>,
<code>Player_Unmute</code>.</dd>
</dl>
<h4>Player_TogglePause</h4>
<p><code>void Player_TogglePause(void)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function toggles the playing/paused status of the
module.<br /></dd>
<dt><i>Notes</i></dt>
<dd>Calls to <code>Player_xx</code> functions still have effect
when the module is paused.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_Paused</code>, <code>Player_Start</code>,
<code>Player_Stop</code>.</dd>
</dl>
<h4>Player_Unmute</h4>
<p><code>void Player_Unmute(SLONG operation, ...)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function unmutes a single module channel, or a range of
module channels.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>operation</i></dt>
<dd>Either the number of a module channel to unmute (starting from
zero), or an operation code. In the latter case, two extra
parameters are needed to determine the range of
channels.<br /></dd>
<dt><i>Notes</i></dt>
<dd>If the operation is <code>MUTE_INCLUSIVE</code>, the two
channel numbers delimit the range and are part of the range ;
otherwise, if the operation is <code>MUTE_EXCLUSIVE</code>, they
are outside of the range.<br /></dd>
<dt><i>Example</i></dt>
<dd>
<pre>
    /* unmute channel 10 */
    Player_Unmute(10);
    /* unmute channels 2 to 5 */
    Player_Unmute(MUTE_INCLUSIVE, 2, 5);
    /* unmute channels 7 to 9 */
    Player_Unmute(MUTE_EXCLUSIVE, 6, 10);
</pre>
<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Player_Mute</code>, <code>Player_Muted</code>,
<code>Player_ToggleMute</code>.</dd>
</dl>
<hr />
Node:<a name="Sample_Functions">Sample Functions</a>,
Next:<a rel="next" href="#Voice_Functions">Voice Functions</a>,
Previous:<a rel="previous" href=
"#Module_Player_Functions">Module Player Functions</a>,
Up:<a rel="up" href="#Function_Reference">Function
Reference</a><br />
<h3>Sample Functions</h3>
<h4>Sample_Free</h4>
<p><code>void Sample_Free(SAMPLE* sample)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function unloads a sample from memory.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>sample</i></dt>
<dd>The sample to free.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Sample_Load</code>, <code>Sample_LoadFP</code>.</dd>
</dl>
<h4>Sample_Load</h4>
<p><code>SAMPLE* Sample_Load(CHAR* filename)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function loads a sample.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>filename</i></dt>
<dd>The sample filename.<br /></dd>
<dt><i>Result</i></dt>
<dd>A pointer to a <code>SAMPLE</code> structure, or
<code>NULL</code> if an error has occurred.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Sample_Free</code>, <code>Sample_LoadFP</code>.</dd>
</dl>
<h4>Sample_LoadFP</h4>
<p><code>SAMPLE* Sample_LoadFP(FILE* file)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function loads a sample.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>file</i></dt>
<dd>An open file, at the position where the sample
starts.<br /></dd>
<dt><i>Result</i></dt>
<dd>A pointer to a <code>SAMPLE</code> structure, or
<code>NULL</code> if an error has occurred.<br /></dd>
<dt><i>Notes</i></dt>
<dd>The file is left open, at the same position as before the
function call.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Sample_Free</code>, <code>Sample_Load</code>.</dd>
</dl>
<h4>Sample_Play</h4>
<p><code>SBYTE Sample_Play(SAMPLE* sample, ULONG start, UBYTE
flags)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function plays a sample as a sound effect.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>sample</i></dt>
<dd>The sample to play.<br /></dd>
<dt><i>start</i></dt>
<dd>The starting position (in samples).<br /></dd>
<dt><i>flags</i></dt>
<dd>Either zero, for normal sound effects, or
<code>SFX_CRITICAL</code>, for critical sound effects which must
not be interrupted.<br /></dd>
<dt><i>Result</i></dt>
<dd>The voice number corresponding to the voice which will play the
sample.<br /></dd>
<dt><i>Notes</i></dt>
<dd>Each new sound effect is played on a new voice. When all voices
are taken, the oldest sample which was not marked as critical is
cut and its voice is used for the new sample. Critical samples are
not cut unless all the voices are taken with critical samples and
you attempt to play yet another critical sample. Use
<code>Voice_Stop</code> to force the end of a critical
sample.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>MikMod_SetNumVoices</code>, <code>Voice_Play</code>,
<code>Voice_SetFrequency</code>, <code>Voice_SetPanning</code>,
<code>Voice_SetVolume</code>, <code>Voice_Stop</code>.</dd>
</dl>
<hr />
Node:<a name="Voice_Functions">Voice Functions</a>, Next:<a rel=
"next" href="#Loader_Reference">Loader Reference</a>,
Previous:<a rel="previous" href="#Sample_Functions">Sample
Functions</a>, Up:<a rel="up" href="#Function_Reference">Function
Reference</a><br />
<h3>Voice Functions</h3>
<h4>Voice_GetFrequency</h4>
<p><code>ULONG Voice_GetFrequency(SBYTE voice)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function returns the frequency of the sample currently
playing on the specified voice.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>voice</i></dt>
<dd>The number of the voice to get frequency.<br /></dd>
<dt><i>Result</i></dt>
<dd>The current frequency of the sample playing on the specified
voice, or zero if no sample is currently playing on the
voice.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Voice_SetFrequency</code>.</dd>
</dl>
<h4>Voice_GetPanning</h4>
<p><code>ULONG Voice_GetPanning(SBYTE voice)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function returns the panning position of the sample
currently playing on the specified voice.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>voice</i></dt>
<dd>The number of the voice to get panning position.<br /></dd>
<dt><i>Result</i></dt>
<dd>The current panning position of the sample playing on the
specified voice, or <code>PAN_CENTER</code> if no sample is
currently playing on the voice.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Voice_SetPanning</code>.</dd>
</dl>
<h4>Voice_GetPosition</h4>
<p><code>SLONG Voice_GetPosition(SBYTE voice)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function returns the sample position (in samples) of the
sample currently playing on the specified voice.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>voice</i></dt>
<dd>The number of the voice to get sample position (starting from
zero).<br /></dd>
<dt><i>Result</i></dt>
<dd>The current play location of the sample playing on the
specified voice, or zero if the position can not be determined or
if no sample is currently playing on the voice.<br /></dd>
<dt><i>Notes</i></dt>
<dd>This function may not work with some drivers (especially for
hardware mixed voices). In this case, it returns always
<code>-1</code>.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Sample_Play</code>, <code>Voice_Play</code>.</dd>
</dl>
<h4>Voice_GetVolume</h4>
<p><code>UWORD Voice_GetVolume(SBYTE voice)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function returns the volume of the sample currently
playing on the specified voice.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>voice</i></dt>
<dd>The number of the voice to get volume.<br /></dd>
<dt><i>Result</i></dt>
<dd>The current volume of the sample playing on the specified
voice, or zero if no sample is currently playing on the
voice.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Voice_RealVolume</code>,
<code>Voice_SetVolume</code>.</dd>
</dl>
<h4>Voice_Play</h4>
<p><code>void Voice_Play(SBYTE voice, SAMPLE* sample, ULONG
start)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>Start a new sample in the specified voice.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>voice</i></dt>
<dd>The number of the voice to be processed (starting from
zero).<br /></dd>
<dt><i>sample</i></dt>
<dd>The sample to play.<br /></dd>
<dt><i>start</i></dt>
<dd>The starting position (in samples).<br /></dd>
<dt><i>Notes</i></dt>
<dd>The sample will be played at the volume, panning and frequency
settings of the voice, regardless or the sample
characteristics.<br />
The sample played this way gets the same "critical" status as the
sample which was previously played on this voice.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Sample_Play</code>, <code>Voice_SetFrequency</code>,
<code>Voice_SetPanning</code>, <code>Voice_SetVolume</code>.</dd>
</dl>
<h4>Voice_RealVolume</h4>
<p><code>ULONG Voice_RealVolume(SBYTE voice)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function returns the actual playing volume of the
specified voice.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>voice</i></dt>
<dd>The number of the voice to analyze (starting from
zero).<br /></dd>
<dt><i>Result</i></dt>
<dd>The real volume of the voice when the function was called, in
the range 0-65535, not related to the volume constraint specified
with <code>Voice_SetVolume</code>.<br /></dd>
<dt><i>Notes</i></dt>
<dd>This function may not work with some drivers (especially for
hardware mixed voices). In this case, it always returns zero.<br />
Also note that the real volume computation is not a trivial process
and takes some CPU time.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Sample_Play</code>, <code>Voice_GetVolume</code>,
<code>Voice_Play</code>, <code>Voice_SetVolume</code>.</dd>
</dl>
<h4>Voice_SetFrequency</h4>
<p><code>void Voice_SetFrequency(SBYTE voice, ULONG
frequency)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function sets the frequency (pitch) of the specified
voice.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>voice</i></dt>
<dd>The number of the voice to be processed (starting from
zero).<br /></dd>
<dt><i>frequency</i></dt>
<dd>The new frequency of the voice, in hertz.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Sample_Play</code>, <code>Voice_GetFrequency</code>,
<code>Voice_Play</code>, <code>Voice_SetPanning</code>,
<code>Voice_SetVolume</code>, <code>Voice_Stop</code>.</dd>
</dl>
<h4>Voice_SetPanning</h4>
<p><code>void Voice_SetPanning(SBYTE voice, ULONG
panning)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function sets the panning position of the specified
voice.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>voice</i></dt>
<dd>The number of the voice to be processed (starting from
zero).<br /></dd>
<dt><i>panning</i></dt>
<dd>The new panning position of the voice.<br /></dd>
<dt><i>Notes</i></dt>
<dd>Panning can vary between 0 (<code>PAN_LEFT</code>) and 255
(<code>PAN_RIGHT</code>). Center is 127 (<code>PAN_CENTER</code>.
Surround sound can be enabled by specifying the special value
<code>PAN_SURROUND</code>.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Sample_Play</code>, <code>Voice_GetPanning</code>,
<code>Voice_Play</code>, <code>Voice_SetFrequency</code>,
<code>Voice_SetVolume</code>, <code>Voice_Stop</code>.</dd>
</dl>
<h4>Voice_SetVolume</h4>
<p><code>void Voice_SetVolume(SBYTE voice, UWORD volume)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function sets the volume of the specified
voice.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>voice</i></dt>
<dd>The number of the voice to be processed (starting from
zero).<br /></dd>
<dt><i>volume</i></dt>
<dd>The new volume of the voice, in the range 0-256.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Sample_Play</code>, <code>Voice_GetVolume</code>,
<code>Voice_Play</code>, <code>Voice_SetFrequency</code>,
<code>Voice_SetPanning</code>, <code>Voice_Stop</code>.</dd>
</dl>
<h4>Voice_Stop</h4>
<p><code>void Voice_Stop(SBYTE voice)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function stops the playing sample of the specified
voice.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>voice</i></dt>
<dd>The number of the voice to be processed (starting from
zero).<br /></dd>
<dt><i>Notes</i></dt>
<dd>After the call to <code>Voice_Stop</code>, the function
<code>Voice_Stopped</code> will return nonzero (true) for the
voice. If you want to silence the voice without stopping the
playback, use <code>Voice_SetVolume(voice, 0)</code>
instead.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Sample_Play</code>, <code>Voice_Play</code>,
<code>Voice_SetFrequency</code>, <code>Voice_SetPanning</code>,
<code>Voice_SetVolume</code>.</dd>
</dl>
<h4>Voice_Stopped</h4>
<p><code>BOOL Voice_Stopped(SBYTE voice)</code></p>
<dl>
<dt><i>Description</i></dt>
<dd>This function returns whether the voice is active or
not.<br /></dd>
<dt><i>Parameters</i></dt>
<dt><i>voice</i></dt>
<dd>The number of the voice to be checked (starting from
zero).<br /></dd>
<dt><i>Result</i></dt>
<dt><i>0</i></dt>
<dd>The voice is stopped or has no sample assigned.</dd>
<dt><i>nonzero</i></dt>
<dd>The voice is playing a sample.<br /></dd>
<dt><i>Notes</i></dt>
<dd>This function may not work with some drivers (especially for
hardware mixed voices). In this case, its return value is
undefined.<br /></dd>
<dt><i>See also</i></dt>
<dd><code>Voice_Stop</code>.</dd>
</dl>
<hr />
Node:<a name="Loader_Reference">Loader Reference</a>,
Next:<a rel="next" href="#Module_Loaders">Module Loaders</a>,
Previous:<a rel="previous" href="#Voice_Functions">Voice
Functions</a>, Up:<a rel="up" href="#Library_Reference">Library
Reference</a><br />
<h2>Loader Reference</h2>
<ul>
<li><a href="#Module_Loaders">Module Loaders</a>:</li>
<li><a href="#Sample_Loaders">Sample Loaders</a>:</li>
</ul>
<hr />
Node:<a name="Module_Loaders">Module Loaders</a>, Next:<a rel=
"next" href="#Sample_Loaders">Sample Loaders</a>,
Previous:<a rel="previous" href="#Loader_Reference">Loader
Reference</a>, Up:<a rel="up" href="#Loader_Reference">Loader
Reference</a><br />
<h3>Module Loaders</h3>
<p>MikMod presents a large choice of module loaders, for the most
common formats as well as for some less-known exotic formats.</p>
<dl>
<dt><code>load_669</code></dt>
<dd>This loader recognizes "Composer 669" and "Unis 669" modules.
The 669 and "Extended 669" formats were among the first PC module
formats. They do not have a wide range of effects, but support up
to 32 channels.<br />
"Composer 669" was written by Tran of Renaissance, a.k.a. Tomasz
Pytel and released in 1992. "Unis 669 Composer" was written by
Jason Nunn and released in 1994.<br /></dd>
<dt><code>load_amf</code></dt>
<dd>This loader recognizes the "Advanced Module Format", which is
the internal module format of the "DOS Sound and Music Interface"
(DSMI) library. This format has the same limitations as the S3M
format. The most famous DSMI application was DMP, the Dual Module
Player.<br />
DMP and the DSMI library were written by Otto Chrons. DSMI was
first released in 1993.<br /></dd>
<dt><code>load_dsm</code></dt>
<dd>This loader recognizes the internal DSIK format, which is the
internal module format of the "Digital Sound Interface Kit" (DSIK)
library, the ancester of the SEAL library. This format has the same
limitations as the S3M format.<br />
The DSIK library was written by Carlos Hasan and released in
1994.<br /></dd>
<dt><code>load_far</code></dt>
<dd>This loader recognizes "Farandole" modules. These modules can
be up to 16 channels and have Protracker comparable effects.<br />
The Farandole composer was written by Daniel Potter and released in
1994.<br /></dd>
<dt><code>load_gdm</code></dt>
<dd>This loader recognizes the "General DigiMusic" format, which is
the internal format of the "Bells, Whistles and Sound Boards"
library. This format has the same limitations as the S3M
format.<br />
The BWSB library was written by Edward Schlunder and first released
in 1993.<br /></dd>
<dt><code>load_imf</code></dt>
<dd>This loader recognizes "Imago Orpheus" modules. This format is
roughly equivalent to the XM format, but with two effects columns
instead of a volume column and an effect column.<br />
Imago Orpheus was written by Lutz Roeder and released in
1994.<br /></dd>
<dt><code>load_it</code></dt>
<dd>This loader recognizes "Impulse Tracker" modules, currently the
most powerful format. These modules support up to 64 real channels,
and up to 256 virtual channels with the "New Note Action" feature.
Besides, it has the widest range of effects, and supports 16 bit
samples as well as surround sound.<br />
"Impulse Tracker" was written by Jeffrey Lim and released in
1996.<br /></dd>
<dt><code>load_med</code></dt>
<dd>This loader recognizes "OctaMED" modules. These modules are
comparable to Protracker modules, but can embed "synthsounds",
which are midi-like instruments.<br />
"MED" and later "OctaMED" were written by Teijo Kinnunen. "MED" was
released in 1989, and "OctaMED" was released in 1992.<br /></dd>
<dt><code>load_m15</code></dt>
<dd>This loader recognizes the old 15 instrument modules, created
by "Ultimate Soundtracker", "Soundtracker" and the first versions
of "Protracker".<br />
Since this format was one of the first module formats, developed in
1987, it does not have any signature field, which makes it hard to
detect reliably, because of its similarities with later module
formats.<br /></dd>
<dt><code>load_mod</code></dt>
<dd>This loader recognizes the standard 31 instrument modules,
created by "Protracker" or Protracker-compatible programs. The
original Protracker format was limited to 4 channels, but other
trackers like "TakeTracker", "StarTracker" or "Oktalyzer" afforded
more channels.<br />
Although it is now technically obsolete, this format is still
widely used, due to its playback simplicity (on the adequate
hardware, the Amiga).<br /></dd>
<dt><code>load_mtm</code></dt>
<dd>This loader recognizes the "MultiTracker Module Editor"
modules. The MTM format has up to 32 channels, and protracker
comparable effects. It was intended to replace "Composer 669". The
"MultiTracker Module Editor" was written by Starscream of
Renaissance, a.k.a. Daniel Goldstein and released in late
1993.<br /></dd>
<dt><code>load_okt</code></dt>
<dd>This loader recognizes the "Amiga Oktalyzer" modules. The OKT
format has up to 8 channels, and a few protracker compatible
effects, as well as other OKT-specific effects, which are currently
not supported by libmikmod.<br /></dd>
<dt><code>load_stm</code></dt>
<dd>This loader recognizes "ScreamTracker" modules. "ScreamTracker"
was the first PC tracker, as well as the first PC module format.
Loosely inspired by the "SoundTracker" format, it does not have as
many effects as Protracker, although it supports 31 instruments and
4 channels.<br />
"ScreamTracker" was written by PSI of Future Crew, a.k.a. Sami
Tammilehto.<br /></dd>
<dt><code>load_stx</code></dt>
<dd>This loader recognizes "STMIK 0.2" modules. "STMIK" (the Scream
Tracker Music Interface Kit) was a module playing library
distributed by Future Crew to play Scream Tracker module in games
and demos. It uses an intermediate format between STM and S3M and
comes with a tool converting STM modules to STX.<br />
"STMIK" was written by PSI of Future Crew, a.k.a. Sami
Tammilehto.<br /></dd>
<dt><code>load_s3m</code></dt>
<dd>This loader recognizes "ScreamTracker 3" modules. This version
was a huge improvement over the original "ScreamTracker". It
supported 32 channels, up to 99 instruments, and a large choice of
effects.<br />
"ScreamTracker 3" was written by PSI of Future Crew, a.k.a. Sami
Tammilehto, and released in 1994.<br /></dd>
<dt><code>load_ult</code></dt>
<dd>This loader recognizes "UltraTracker" modules. They are mostly
similar to Protracker modules, but support two effects per
channel.<br />
"UltraTracker" was written by MAS of Prophecy, a.k.a. Marc Andre
Schallehn, and released in 1993.<br /></dd>
<dt><code>load_uni</code></dt>
<dd>This loader recognizes "UNIMOD" modules. This is the internal
format used by MikMod and APlayer. Use of this format is
discouraged, this loader being provided for
completeness.<br /></dd>
<dt><code>load_xm</code></dt>
<dd>This loader recognizes "FastTracker 2" modules. This format was
designed from scratch, instead of creating yet another Protracker
variation. It was the first format using instruments as well as
samples, and envelopes for finer effects.<br />
FastTracker 2 was written by Fredrik Huss and Magnus Hogdahl, and
released in 1994.</dd>
</dl>
<hr />
Node:<a name="Sample_Loaders">Sample Loaders</a>, Next:<a rel=
"next" href="#Driver_Reference">Driver Reference</a>,
Previous:<a rel="previous" href="#Module_Loaders">Module
Loaders</a>, Up:<a rel="up" href="#Loader_Reference">Loader
Reference</a><br />
<h3>Sample Loaders</h3>
<p>Currently, the only file type than can be loaded as a sample is
the RIFF WAVE file. Stereo or compressed WAVE files are not
supported yet.</p>
<hr />
Node:<a name="Driver_Reference">Driver Reference</a>,
Next:<a rel="next" href="#Network_Drivers">Network Drivers</a>,
Previous:<a rel="previous" href="#Sample_Loaders">Sample
Loaders</a>, Up:<a rel="up" href="#Library_Reference">Library
Reference</a><br />
<h2>Driver Reference</h2>
<ul>
<li><a href="#Network_Drivers">Network Drivers</a>:</li>
<li><a href="#Hardware_Drivers">Hardware Drivers</a>:</li>
<li><a href="#Disk_Writer_Drivers">Disk Writer
Drivers</a>:</li>
<li><a href="#Other_Drivers">Other Drivers</a>:</li>
</ul>
<hr />
Node:<a name="Network_Drivers">Network Drivers</a>, Next:<a rel=
"next" href="#Hardware_Drivers">Hardware Drivers</a>,
Previous:<a rel="previous" href="#Driver_Reference">Driver
Reference</a>, Up:<a rel="up" href="#Driver_Reference">Driver
Reference</a><br />
<h3>Network Drivers</h3>
<p>These drivers send the generated sound over the network to a
server program, which sends the sound to the real sound hardware.
The server program can be on the same machine than your program,
but MikMod does not have access to the hardware. Network drivers
only support software mixing.</p>
<dl>
<dt><code>drv_AF</code></dt>
<dd>This driver works with the "Digital AudioFile" library.<br />
Start the server on the machine you want, set its hostname in the
<code>AUDIOFILE</code> environment variable, and MikMod is ready to
send it sound.<br /></dd>
<dt><code>drv_esd</code></dt>
<dd>This driver works with the "Enlightened Sound Daemon".<br />
Start the esd daemon on the machine you want, set its hostname in
the <code>ESPEAKER</code> environment variable, and MikMod is ready
to send it sound.</dd>
</dl>
<hr />
Node:<a name="Hardware_Drivers">Hardware Drivers</a>,
Next:<a rel="next" href="#Disk_Writer_Drivers">Disk Writer
Drivers</a>, Previous:<a rel="previous" href=
"#Network_Drivers">Network Drivers</a>, Up:<a rel="up" href=
"#Driver_Reference">Driver Reference</a><br />
<h3>Hardware Drivers</h3>
<p>These drivers access to the sound hardware of the machine they
run on. Depending on your Unix flavor, you'll end with one or more
drivers from this list:</p>
<dl>
<dt><code>drv_aix</code></dt>
<dd>This driver is only available under AIX, and access its audio
device.<br />
This driver only supports software mixing.<br /></dd>
<dt><code>drv_alsa</code></dt>
<dd>This driver is only available under Linux, and requires the
ALSA driver to be compiled for your current kernel.<br />
This driver only supports software mixing, but a future version of
the driver might be able to use the hardware capabilities of some
sound cards.<br /></dd>
<dt><code>drv_dart</code></dt>
<dd>This driver is only available under OS/2 version 3 and higher
(Warp), and uses the "Direct Audio Real-Time" interface.<br />
This driver only supports software mixing.<br /></dd>
<dt><code>drv_hp</code></dt>
<dd>This driver is only available under HP-UX, and access its audio
device.<br />
This driver only supports software mixing.<br /></dd>
<dt><code>drv_os2</code></dt>
<dd>This driver is only available under OS/2 version 3 and higher
(Warp), and OS/2 2.x with MMPM/2.<br />
This driver only supports software mixing.<br /></dd>
<dt><code>drv_oss</code></dt>
<dd>This driver is available under any Unix with the Open Sound
System drivers installed. Linux and FreeBSD also come with the
OSS/Lite driver (the non-commercial version of OSS) and can make
use of this driver.<br />
This driver only supports software mixing.<br /></dd>
<dt><code>drv_sam9407</code></dt>
<dd>This driver is only available under Linux, and requires the
Linux sam9407 driver to be compiled for your current kernel.<br />
This driver only supports hardware mixing.<br /></dd>
<dt><code>drv_sgi</code></dt>
<dd>This driver is only available under IRIX, and uses the SGI
audio library.<br />
This driver only supports software mixing.<br /></dd>
<dt><code>drv_sun</code></dt>
<dd>This driver is only available under Unices which implement
SunOS-like audio device interfaces, that is, SunOS, Solaris, NetBSD
and OpenBSD.<br />
This driver only supports software mixing.<br /></dd>
<dt><code>drv_ultra</code></dt>
<dd>This driver is only available under Linux, and requires the
Linux Ultrasound driver (the ancestor of ALSA) to be compiled for
your current kernel.<br />
This driver only supports hardware mixing.</dd>
</dl>
<hr />
Node:<a name="Disk_Writer_Drivers">Disk Writer Drivers</a>,
Next:<a rel="next" href="#Other_Drivers">Other Drivers</a>,
Previous:<a rel="previous" href="#Hardware_Drivers">Hardware
Drivers</a>, Up:<a rel="up" href="#Driver_Reference">Driver
Reference</a><br />
<h3>Disk Writer Drivers</h3>
<p>These drivers work on any machine, since the generated sound is
not sent to hardware, but written in a file. Disk writer drivers
only support software mixing.</p>
<dl>
<dt><code>drv_raw</code></dt>
<dd>This driver outputs the sound date in a file by default named
<code>music.raw</code> in the current directory. The file has no
header and only contains the sound output.<br /></dd>
<dt><code>drv_wav</code></dt>
<dd>This driver outputs the sound data in a RIFF WAVE file by
default named <code>music.wav</code> in the current directory.</dd>
</dl>
<hr />
Node:<a name="Other_Drivers">Other Drivers</a>, Previous:<a rel=
"previous" href="#Disk_Writer_Drivers">Disk Writer Drivers</a>,
Up:<a rel="up" href="#Driver_Reference">Driver
Reference</a><br />
<h3>Other Drivers</h3>
<p>These drivers are of little interest, but are handy
sometimes.</p>
<dl>
<dt><code>drv_stdout</code></dt>
<dd>This driver outputs the sound data to the program's standard
output. To avoid inconvenience, the data will not be output if the
standard output is a terminal, thus you have to pipe it through
another command or to redirect it to a file. Using this driver and
redirecting to a file is equivalent to using the
<code>drv_raw</code> disk writer.<br />
This driver only supports software mixing.<br /></dd>
<dt><code>drv_pipe</code></dt>
<dd>This driver pipes the sound data to a command (which must be
given in the driver commandline, via
<code>MikMod_Init</code>).<br />
This driver only supports software mixing.<br /></dd>
<dt><code>drv_nos</code></dt>
<dd>This driver doesn't produce sound at all, and will work on any
machine.<br />
Since it does not have to produce sound, it supports both hardware
and software mixing, with as many hardware voices as you like.</dd>
</dl>
<hr />
Node:<a name="Index" id="Index">Index</a>, Next:<a rel="next" href=
"#Function_Index">Function Index</a>, Previous:<a rel="previous"
href="#Library_Reference">Library Reference</a>, Up:<a rel="up"
href="#Top">Top</a><br />
<h1>Index</h1>
<ul>
<li><a href="#Function_Index">Function Index</a>:</li>
<li><a href="#Type_and_Variable_Index">Type and Variable
Index</a>:</li>
</ul>
<hr />
Node:<a name="Function_Index">Function Index</a>, Next:<a rel=
"next" href="#Type_and_Variable_Index">Type and Variable
Index</a>, Previous:<a rel="previous" href="#Index">Index</a>,
Up:<a rel="up" href="#Index">Index</a><br />
<h1>Function Index</h1>
<ul compact="compact">
<li><code>MikMod_Active</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_DisableOutput</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_EnableOutput</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_Exit</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_GetVersion</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_InfoDriver</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_InfoLoader</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_Init</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_InitThreads</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_Lock</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_RegisterAllDrivers</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_RegisterAllLoaders</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_RegisterDriver</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_RegisterErrorHandler</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_RegisterLoader</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_RegisterPlayer</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_Reset</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_SetNumVoices</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_strerror</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_Unlock</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>MikMod_Update</code>: <a href=
"#Library_Core_Functions">Library Core Functions</a></li>
<li><code>Player_Active</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_Free</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_GetChannelVoice</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_GetModule</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_Load</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_LoadFP</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_LoadTitle</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_LoadTitleFP</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_Mute</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_Muted</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_NextPosition</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_Paused</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_PrevPosition</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_SetPosition</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_SetSpeed</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_SetTempo</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_SetVolume</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_Start</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_Stop</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_ToggleMute</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_TogglePause</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Player_Unmute</code>: <a href=
"#Module_Player_Functions">Module Player Functions</a></li>
<li><code>Sample_Free</code>: <a href="#Sample_Functions">Sample
Functions</a></li>
<li><code>Sample_Load</code>: <a href="#Sample_Functions">Sample
Functions</a></li>
<li><code>Sample_LoadFP</code>: <a href=
"#Sample_Functions">Sample Functions</a></li>
<li><code>Sample_Play</code>: <a href="#Sample_Functions">Sample
Functions</a></li>
<li><code>Voice_GetFrequency</code>: <a href=
"#Voice_Functions">Voice Functions</a></li>
<li><code>Voice_GetPanning</code>: <a href=
"#Voice_Functions">Voice Functions</a></li>
<li><code>Voice_GetPosition</code>: <a href=
"#Voice_Functions">Voice Functions</a></li>
<li><code>Voice_GetVolume</code>: <a href=
"#Voice_Functions">Voice Functions</a></li>
<li><code>Voice_Play</code>: <a href="#Voice_Functions">Voice
Functions</a></li>
<li><code>Voice_RealVolume</code>: <a href=
"#Voice_Functions">Voice Functions</a></li>
<li><code>Voice_SetFrequency</code>: <a href=
"#Voice_Functions">Voice Functions</a></li>
<li><code>Voice_SetPanning</code>: <a href=
"#Voice_Functions">Voice Functions</a></li>
<li><code>Voice_SetVolume</code>: <a href=
"#Voice_Functions">Voice Functions</a></li>
<li><code>Voice_Stop</code>: <a href="#Voice_Functions">Voice
Functions</a></li>
<li><code>Voice_Stopped</code>: <a href="#Voice_Functions">Voice
Functions</a></li>
</ul>
<hr />
Node:<a name="Type_and_Variable_Index">Type and Variable
Index</a>, Previous:<a rel="previous" href=
"#Function_Index">Function Index</a>, Up:<a rel="up" href=
"#Index">Index</a><br />
<h1>Type and Variable Index</h1>
<ul compact="compact">
<li><code>INSTRUMENT</code>: <a href=
"#Structure_Reference">Structure Reference</a></li>
<li><code>md_device</code>: <a href=
"#Variable_Reference">Variable Reference</a></li>
<li><code>md_driver</code>: <a href=
"#Variable_Reference">Variable Reference</a></li>
<li><code>md_mixfreq</code>: <a href=
"#Variable_Reference">Variable Reference</a></li>
<li><code>md_mode</code>: <a href="#Variable_Reference">Variable
Reference</a></li>
<li><code>md_musicvolume</code>: <a href=
"#Variable_Reference">Variable Reference</a></li>
<li><code>md_pansep</code>: <a href=
"#Variable_Reference">Variable Reference</a></li>
<li><code>md_reverb</code>: <a href=
"#Variable_Reference">Variable Reference</a></li>
<li><code>md_sndfxvolume</code>: <a href=
"#Variable_Reference">Variable Reference</a></li>
<li><code>md_volume</code>: <a href=
"#Variable_Reference">Variable Reference</a></li>
<li><code>MDRIVER</code>: <a href=
"#Structure_Reference">Structure Reference</a></li>
<li><code>MikMod_critical</code>: <a href=
"#Variable_Reference">Variable Reference</a></li>
<li><code>MikMod_errno</code>: <a href=
"#Variable_Reference">Variable Reference</a></li>
<li><code>MODULE</code>: <a href="#Structure_Reference">Structure
Reference</a></li>
<li><code>MREADER</code>: <a href=
"#Structure_Reference">Structure Reference</a></li>
<li><code>MWRITER</code>: <a href=
"#Structure_Reference">Structure Reference</a></li>
<li><code>SAMPLE</code>: <a href="#Structure_Reference">Structure
Reference</a></li>
</ul>
<h1>Table of Contents</h1>
<ul>
<li><a href="#Top">MikMod Sound Library</a></li>
<li><a href="#Introduction">Introduction</a></li>
<li><a href="#Tutorial">Tutorial</a>
<ul>
<li><a href="#MikMod_Concepts">MikMod Concepts</a></li>
<li><a href="#A_Skeleton_Program">A Skeleton Program</a></li>
<li><a href="#Playing_Modules">Playing Modules</a></li>
<li><a href="#Playing_Sound_Effects">Playing Sound
Effects</a></li>
<li><a href="#More_Sound_Effects">More Sound Effects</a></li>
</ul>
</li>
<li><a href="#Using_the_Library">Using the Library</a>
<ul>
<li><a href="#Library_Version">Library Version</a></li>
<li><a href="#Type_Definitions">Type Definitions</a></li>
<li><a href="#Error_Handling">Error Handling</a></li>
<li><a href="#Library_Initialization">Library Initialization and
Core Functions</a></li>
<li><a href="#Samples_and_Voice_Control">Samples and Voice
Control</a></li>
<li><a href="#Modules_and_Player_Control">Modules and Player
Control</a></li>
<li><a href="#Loading_Data_from_Memory">Loading Data from
Memory</a></li>
</ul>
</li>
<li><a href="#Library_Reference">Library Reference</a>
<ul>
<li><a href="#Variable_Reference">Variable Reference</a>
<ul>
<li><a href="#Variable_Reference">Error Variables</a></li>
<li><a href="#Variable_Reference">Sound Settings</a></li>
<li><a href="#Variable_Reference">Driver Settings</a></li>
</ul>
</li>
<li><a href="#Structure_Reference">Structure Reference</a>
<ul>
<li><a href="#Structure_Reference">Drivers</a></li>
<li><a href="#Structure_Reference">Modules</a>
<ul>
<li><a href="#Structure_Reference">General Module
Information</a></li>
<li><a href="#Structure_Reference">Playback Settings</a></li>
</ul>
</li>
<li><a href="#Structure_Reference">Module Instruments</a></li>
<li><a href="#Structure_Reference">Samples</a></li>
<li><a href="#Structure_Reference">MREADER</a></li>
<li><a href="#Structure_Reference">MWRITER</a></li>
</ul>
</li>
<li><a href="#Error_Reference">Error Reference</a>
<ul>
<li><a href="#Error_Reference">General Errors</a></li>
<li><a href="#Error_Reference">Sample Errors</a></li>
<li><a href="#Error_Reference">Module Errors</a></li>
<li><a href="#Error_Reference">Driver Errors</a>
<ul>
<li><a href="#Error_Reference">Generic Driver Errors</a></li>
<li><a href="#Error_Reference">AudioFile Driver Specific
Error</a></li>
<li><a href="#Error_Reference">AIX Driver Specific
Errors</a></li>
<li><a href="#Error_Reference">Ultra Driver Specific
Errors</a></li>
<li><a href="#Error_Reference">HP-UX Driver Specific
Errors</a></li>
<li><a href="#Error_Reference">Open Sound System Driver Specific
Errors</a></li>
<li><a href="#Error_Reference">SGI Driver Specific
Errors</a></li>
<li><a href="#Error_Reference">Sun Driver Specific Error</a></li>
<li><a href="#Error_Reference">OS/2 Driver Specific
Errors</a></li>
<li><a href="#Error_Reference">DirectX Driver Specific
Errors</a></li>
<li><a href="#Error_Reference">Windows Multimedia API Driver
Specific Errors</a></li>
<li><a href="#Error_Reference">MacOS Driver Specific
Errors</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Function_Reference">Function Reference</a>
<ul>
<li><a href="#Library_Core_Functions">Library Core
Functions</a>
<ul>
<li><a href="#Library_Core_Functions">MikMod_Active</a></li>
<li><a href=
"#Library_Core_Functions">MikMod_DisableOutput</a></li>
<li><a href=
"#Library_Core_Functions">MikMod_EnableOutput</a></li>
<li><a href="#Library_Core_Functions">MikMod_Exit</a></li>
<li><a href=
"#Library_Core_Functions">MikMod_GetVersion</a></li>
<li><a href=
"#Library_Core_Functions">MikMod_InfoDriver</a></li>
<li><a href=
"#Library_Core_Functions">MikMod_InfoLoader</a></li>
<li><a href="#Library_Core_Functions">MikMod_Init</a></li>
<li><a href=
"#Library_Core_Functions">MikMod_InitThreads</a></li>
<li><a href="#Library_Core_Functions">MikMod_Lock</a></li>
<li><a href=
"#Library_Core_Functions">MikMod_RegisterAllDrivers</a></li>
<li><a href=
"#Library_Core_Functions">MikMod_RegisterAllLoaders</a></li>
<li><a href=
"#Library_Core_Functions">MikMod_RegisterDriver</a></li>
<li><a href=
"#Library_Core_Functions">MikMod_RegisterErrorHandler</a></li>
<li><a href=
"#Library_Core_Functions">MikMod_RegisterLoader</a></li>
<li><a href=
"#Library_Core_Functions">MikMod_RegisterPlayer</a></li>
<li><a href="#Library_Core_Functions">MikMod_Reset</a></li>
<li><a href=
"#Library_Core_Functions">MikMod_SetNumVoices</a></li>
<li><a href="#Library_Core_Functions">MikMod_Unlock</a></li>
<li><a href="#Library_Core_Functions">MikMod_Update</a></li>
<li><a href="#Library_Core_Functions">MikMod_strerror</a></li>
</ul>
</li>
<li><a href="#Module_Player_Functions">Module Player
Functions</a>
<ul>
<li><a href="#Module_Player_Functions">Player_Active</a></li>
<li><a href="#Module_Player_Functions">Player_Free</a></li>
<li><a href=
"#Module_Player_Functions">Player_GetChannelVoice</a></li>
<li><a href=
"#Module_Player_Functions">Player_GetModule</a></li>
<li><a href="#Module_Player_Functions">Player_Load</a></li>
<li><a href="#Module_Player_Functions">Player_LoadFP</a></li>
<li><a href=
"#Module_Player_Functions">Player_LoadTitle</a></li>
<li><a href=
"#Module_Player_Functions">Player_LoadTitleFP</a></li>
<li><a href="#Module_Player_Functions">Player_Mute</a></li>
<li><a href="#Module_Player_Functions">Player_Muted</a></li>
<li><a href=
"#Module_Player_Functions">Player_NextPosition</a></li>
<li><a href="#Module_Player_Functions">Player_Paused</a></li>
<li><a href=
"#Module_Player_Functions">Player_PrevPosition</a></li>
<li><a href=
"#Module_Player_Functions">Player_SetPosition</a></li>
<li><a href="#Module_Player_Functions">Player_SetSpeed</a></li>
<li><a href="#Module_Player_Functions">Player_SetTempo</a></li>
<li><a href=
"#Module_Player_Functions">Player_SetVolume</a></li>
<li><a href="#Module_Player_Functions">Player_Start</a></li>
<li><a href="#Module_Player_Functions">Player_Stop</a></li>
<li><a href=
"#Module_Player_Functions">Player_ToggleMute</a></li>
<li><a href=
"#Module_Player_Functions">Player_TogglePause</a></li>
<li><a href="#Module_Player_Functions">Player_Unmute</a></li>
</ul>
</li>
<li><a href="#Sample_Functions">Sample Functions</a>
<ul>
<li><a href="#Sample_Functions">Sample_Free</a></li>
<li><a href="#Sample_Functions">Sample_Load</a></li>
<li><a href="#Sample_Functions">Sample_LoadFP</a></li>
<li><a href="#Sample_Functions">Sample_Play</a></li>
</ul>
</li>
<li><a href="#Voice_Functions">Voice Functions</a>
<ul>
<li><a href="#Voice_Functions">Voice_GetFrequency</a></li>
<li><a href="#Voice_Functions">Voice_GetPanning</a></li>
<li><a href="#Voice_Functions">Voice_GetPosition</a></li>
<li><a href="#Voice_Functions">Voice_GetVolume</a></li>
<li><a href="#Voice_Functions">Voice_Play</a></li>
<li><a href="#Voice_Functions">Voice_RealVolume</a></li>
<li><a href="#Voice_Functions">Voice_SetFrequency</a></li>
<li><a href="#Voice_Functions">Voice_SetPanning</a></li>
<li><a href="#Voice_Functions">Voice_SetVolume</a></li>
<li><a href="#Voice_Functions">Voice_Stop</a></li>
<li><a href="#Voice_Functions">Voice_Stopped</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Loader_Reference">Loader Reference</a>
<ul>
<li><a href="#Module_Loaders">Module Loaders</a></li>
<li><a href="#Sample_Loaders">Sample Loaders</a></li>
</ul>
</li>
<li><a href="#Driver_Reference">Driver Reference</a>
<ul>
<li><a href="#Network_Drivers">Network Drivers</a></li>
<li><a href="#Hardware_Drivers">Hardware Drivers</a></li>
<li><a href="#Disk_Writer_Drivers">Disk Writer Drivers</a></li>
<li><a href="#Other_Drivers">Other Drivers</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#Index">Index</a></li>
<li><a href="#Function_Index">Function Index</a></li>
<li><a href="#Type_and_Variable_Index">Type and Variable
Index</a></li>
</ul>
<hr />
<h4>Footnotes</h4>
<ol type="1">
<li><a name="fn-1" id="fn-1"></a>
<p><code>PAN_SURROUND</code> will be mapped to
<code>PAN_CENTER</code> if the library is initialized without
surround sound, that is, if the variable <code>md_mode</code>
doesn't have the bit <code>DMODE_SURROUND</code> set.</p>
</li>
<li><a name="fn-2" id="fn-2"></a>
<p>Unless you explicitely choose to create a non thread-safe
version of libmikmod at compile-time.</p>
</li>
<li><a name="fn-3" id="fn-3"></a>
<p>You can force libmikmod to load the module (without the
synthsounds, of course) by setting the <code>curious</code>
parameter to <code>1</code> when invoking
<code>Player_Loadxx</code>.</p>
</li>
</ol>
<hr />
</body>
</html>
